<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Vine (å•è¯é•¿é’)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #121212; /* æ·±è‰²æç®€èƒŒæ™¯ */
            font-family: 'Courier New', Courier, monospace; /* æç®€ç­‰å®½å­—ä½“ */
            touch-action: none; /* ç¦ç”¨é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼Œå¦‚åŒå‡»ç¼©æ”¾ */
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 14px;
            box-sizing: border-box;
            color: rgba(255, 255, 255, 0.8);
        }
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            gap: 8px;
        }
        #meaningDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #meaningDisplay .word {
            font-size: 64px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 5px;
        }
        #meaningDisplay .meaning {
            font-size: 36px;
            font-weight: normal;
        }
        .show-meaning {
            opacity: 1 !important;
        }
        
        /* åŠ¨æ€è¿›åº¦æ¡ (The Growth Gauge) */
        #progressGauge {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 5;
        }
        .gauge-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            transition: all 0.3s ease;
        }
        .gauge-dot.completed {
            background: #4CAF50;
            border-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }
        .gauge-dot.current {
            border-color: #fff;
            animation: breathe 1.5s infinite alternate;
        }
        @keyframes breathe {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255,255,255,0.5); }
            100% { transform: scale(1.5); box-shadow: 0 0 15px rgba(255,255,255,1); }
        }

        /* ç»“ç®—å¡ç‰‡ */
        #settlementCard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #4CAF50;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            color: white;
            z-index: 15;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.3);
        }
        #settlementCard.hidden {
            display: none;
        }
        
        /* èœå•æ ·å¼ */
        #menuLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(18, 18, 18, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
        }
        .menu-box {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #4CAF50;
            width: 80%;
            max-width: 500px;
            text-align: center;
        }
        textarea {
            width: 100%;
            height: 150px;
            background: #111;
            color: #4CAF50;
            border: 1px solid #333;
            padding: 10px;
            font-family: monospace;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 5px;
            font-family: inherit;
        }
        button:hover {
            background: #45a049;
        }
        select {
            padding: 10px;
            font-size: 16px;
            background: #111;
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 5px;
            margin-bottom: 20px;
            width: 100%;
        }
        .hidden {
            display: none !important;
        }
        
        /* å¼ºåˆ¶è®°å¿†å±‚æ ·å¼ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
        }
        .overlay-content {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #4CAF50;
            text-align: center;
            max-width: 80%;
        }
        .overlay-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-family: 'Courier New', Courier, monospace;
        }
        .overlay-btn.secondary {
            background: #555;
        }
        .overlay-btn:hover {
            opacity: 0.9;
        }
        #memorizeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
        }

        .overlay-content {
            width: min(92vw, 640px);
            max-width: 92vw;
        }
        .overlay-content h2 {
            font-size: clamp(20px, 5.2vw, 30px);
            line-height: 1.3;
            word-break: break-word;
        }
        .overlay-content p {
            font-size: clamp(14px, 3.8vw, 18px);
            line-height: 1.6;
        }
        #quickMemoList {
            font-size: clamp(14px, 3.8vw, 20px) !important;
            line-height: 1.7 !important;
        }
        #dailyStatsOverlay .overlay-content > div {
            font-size: clamp(14px, 3.8vw, 18px) !important;
            line-height: 2 !important;
        }
        #settlementTitle {
            font-size: clamp(20px, 5vw, 32px);
            line-height: 1.3;
        }
        #settlementStats {
            font-size: clamp(18px, 4.8vw, 24px) !important;
        }
        #settlementCard p {
            font-size: clamp(12px, 3.6vw, 16px) !important;
        }
        #memorizeOverlay h2 {
            font-size: clamp(24px, 8vw, 40px) !important;
            line-height: 1.25;
            text-align: center;
            max-width: 92vw;
            padding: 0 12px;
            box-sizing: border-box;
        }
        #memoWord {
            font-size: clamp(36px, 13vw, 64px) !important;
            letter-spacing: clamp(1px, 0.9vw, 5px) !important;
            max-width: 94vw;
            text-align: center;
            overflow-wrap: anywhere;
            word-break: break-word;
            box-sizing: border-box;
            padding: 0 8px;
        }
        #memoMeaning {
            font-size: clamp(22px, 7vw, 36px) !important;
            line-height: 1.35;
            max-width: 94vw;
            text-align: center;
            overflow-wrap: anywhere;
            word-break: break-word;
            box-sizing: border-box;
            padding: 0 10px;
        }
        #memoCountdown {
            font-size: clamp(36px, 12vw, 64px) !important;
        }

        @media (orientation: portrait) {
            .overlay-content {
                padding: 20px 16px;
                max-width: 90%;
            }
            .overlay-content h2 {
                font-size: 18px;
            }
            .overlay-content p {
                font-size: 14px;
            }
            .overlay-btn {
                font-size: 14px;
                padding: 8px 16px;
            }
            #quickMemoList {
                font-size: 14px !important;
                line-height: 1.6 !important;
            }
            #memorizeOverlay h2 {
                font-size: 22px;
            }
            #memorizeOverlay #memoWord {
                font-size: 36px;
            }
            #memorizeOverlay #memoMeaning {
                font-size: 22px;
            }
            #memorizeOverlay #memoCountdown {
                font-size: 40px;
            }
            #settlementCard {
                padding: 24px;
            }
            #settlementCard h2 {
                font-size: 20px;
            }
            #settlementCard p {
                font-size: 16px;
            }
        }

        @media (orientation: portrait) and (max-width: 414px) {
            #quickMemoList {
                font-size: 12px !important;
                line-height: 1.5 !important;
            }
            .overlay-content {
                padding: 14px 12px;
            }
            #memorizeOverlay #memoWord {
                font-size: 28px;
            }
            #memorizeOverlay #memoMeaning {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- èœå•å±‚ -->
    <div id="menuLayer">
        <div class="menu-box">
            <h1 style="color: #4CAF50; margin-top: 0;">Word Vine</h1>
            
            <h3>é€‰æ‹©è¯åº“</h3>
            <div style="display: flex; gap: 10px; width: 100%; margin-bottom: 20px;">
                <select id="dictSelect" style="margin-bottom: 0; flex-grow: 1;"></select>
                <button id="resetDictBtn" style="background: #ff9800; margin: 0;">é‡ç½®</button>
                <button id="deleteDictBtn" style="background: #f44336; margin: 0;">åˆ é™¤</button>
            </div>
            <button id="startBtn">å¼€å§‹æ¸¸æˆ</button>
            
            <hr style="border-color: #333; margin: 20px 0;">
            
            <h3>å¯¼å…¥æ–°è¯åº“ (JSON)</h3>
            <p style="font-size: 12px; color: #aaa; text-align: left;">æ ¼å¼: {"apple": "è‹¹æœ", "tree": "æ ‘"}</p>
            <input type="text" id="dictNameInput" placeholder="è¯åº“åç§° (å¦‚: CET4)" style="width: 100%; padding: 10px; margin-bottom: 10px; box-sizing: border-box; background: #111; color: white; border: 1px solid #333;">
            <textarea id="importData" placeholder='{"word": "meaning"}'></textarea>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                <input type="file" id="fileInput" accept=".json" style="display: none;">
                <button id="loadFileBtn" style="background: #333; border: 1px solid #555;">ä»æ–‡ä»¶åŠ è½½</button>
                <button id="importBtn">ä¿å­˜å¹¶å¯¼å…¥</button>
            </div>
            <div id="importMsg" style="color: #f44336; font-size: 14px; margin-top: 10px;"></div>
        </div>
    </div>

    <div id="uiLayer" class="hidden">
        <div class="top-bar">
            <div style="display: flex; flex-direction: column; align-items: flex-start; min-width: 50px;">
                <div id="scoreDisplay" style="font-size: 16px;">0</div>
                <div id="comboDisplay" style="font-size: 12px; color: #aaa; margin-top: 2px;">x1</div>
            </div>
            <div style="flex-grow: 1; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                <div id="selectedLettersDisplay" style="font-size: 14px; color: #fff; letter-spacing: 2px; font-weight: bold; text-shadow: 0 0 10px rgba(76,175,80,0.6); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60vw;"></div>
                <div id="currentMeaningDisplay" style="font-size: 13px; color: #4CAF50;"></div>
            </div>
            <div id="progressDisplay" style="font-size: 12px; color: #aaa; min-width: 50px; text-align: right;">0/0</div>
        </div>
        <div id="meaningDisplay"></div>
        <div id="progressGauge"></div>
        <button id="exitBtn" style="position: absolute; bottom: 20px; left: 20px; pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #aaa; padding: 8px 14px; font-size: 14px; border-radius: 20px; cursor: pointer; font-family: inherit;" onclick="confirmExit()">â†© é€€å‡º</button>
        <button id="statsBtn" style="position: absolute; bottom: 20px; right: 20px; pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #aaa; padding: 8px 14px; font-size: 14px; border-radius: 20px; cursor: pointer; font-family: inherit;" onclick="showDailyStats()">ğŸ“Š ä»Šæ—¥ç»Ÿè®¡</button>
    </div>

    <!-- æ¯æ—¥ç»Ÿè®¡æµ®å±‚ -->
    <div id="dailyStatsOverlay" class="overlay hidden">
        <div class="overlay-content" style="min-width: 260px; width: 75%; max-width: 400px;">
            <h2 style="color: #4CAF50; margin-top: 0; margin-bottom: 20px;">ğŸ“Š ä»Šæ—¥ç»Ÿè®¡</h2>
            <div style="text-align: left; font-size: 18px; line-height: 2.2;">
                <div style="display: flex; justify-content: space-between;"><span>å®Œæˆå•è¯</span><span id="statWords" style="color: #4CAF50; font-weight: bold;">0</span></div>
                <div style="display: flex; justify-content: space-between;"><span>é”™è¯¯æ¬¡æ•°</span><span id="statMistakes" style="color: #ff9800; font-weight: bold;">0</span></div>
                <div style="display: flex; justify-content: space-between;"><span>æ­»äº¡æ¬¡æ•°</span><span id="statDeaths" style="color: #f44336; font-weight: bold;">0</span></div>
            </div>
            <button class="overlay-btn" style="width: 100%; margin-top: 20px;" onclick="hideDailyStats()">å…³é—­</button>
        </div>
    </div>

    <!-- ç»“ç®—å¡ç‰‡ -->
    <div id="settlementCard" class="hidden">
        <h2 id="settlementTitle" style="color: #4CAF50; margin-top: 0;">Cluster Complete</h2>
        <p id="settlementStats" style="font-size: 24px; margin: 20px 0;">Accuracy: 100%</p>
        <p style="font-size: 14px; color: #aaa;">Press Space to continue</p>
    </div>

    <!-- å¿«é€Ÿè®°å¿†è¯¢é—®å±‚ -->
    <div id="quickMemoPromptOverlay" class="overlay hidden">
        <div class="overlay-content">
            <h2 style="color: #4CAF50; margin-top: 0;">æ–°çš„ä¸€ç»„å•è¯å³å°†å¼€å§‹</h2>
            <p style="font-size: 18px; margin: 20px 0; color: #ccc;">æ˜¯å¦éœ€è¦å…ˆå¿«é€Ÿæµè§ˆå¹¶è®°å¿†æœ¬ç»„å•è¯ï¼Ÿ</p>
            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="btnQuickMemoYes" class="overlay-btn">éœ€è¦è®°å¿† (Y)</button>
                <button id="btnQuickMemoNo" class="overlay-btn secondary">ç›´æ¥å¼€å§‹ (N)</button>
            </div>
        </div>
    </div>

    <!-- å¿«é€Ÿè®°å¿†å±•ç¤ºå±‚ -->
    <div id="quickMemoDisplayOverlay" class="overlay hidden">
        <div class="overlay-content" style="max-width: 600px; width: 80%;">
            <h2 style="color: #4CAF50; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 10px;">æœ¬ç»„å•è¯é¢„è§ˆ</h2>
            <div id="quickMemoList" style="text-align: left; margin: 15px 0; max-height: 55vh; overflow-y: auto; font-size: 20px; line-height: 1.8;">
                <!-- å•è¯åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button id="btnQuickMemoDone" class="overlay-btn" style="width: 100%;">æˆ‘è®°ä½äº†ï¼Œå¼€å§‹æŒ‘æˆ˜ (Space)</button>
        </div>
    </div>

    <!-- å¼ºåˆ¶è®°å¿†å±‚ -->
    <div id="memorizeOverlay" class="overlay hidden">
        <h2 style="color: #f44336; font-size: 32px; margin-bottom: 10px;">é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·å¼ºåˆ¶è®°å¿†ï¼</h2>
        <div id="memoWord" style="font-size: 64px; color: #4CAF50; font-weight: bold; letter-spacing: 5px; margin: 20px 0;"></div>
        <div id="memoMeaning" style="font-size: 36px; margin-bottom: 40px;"></div>
        <div id="memoCountdown" style="font-size: 64px; font-weight: bold; color: #ff9800;">10</div>
    </div>

    <script>
        // --- 1. åˆå§‹åŒ– Canvas ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let gameStateReady = false;
        
        function resize() {
            const prevWidth = width;
            const prevHeight = height;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            if (gameStateReady && Number.isFinite(prevWidth) && Number.isFinite(prevHeight)) {
                adjustTreePositionOnResize(prevWidth, prevHeight, width, height);
            }
        }
        
        window.addEventListener('resize', resize);
        resize();

        // --- 2. æ ¸å¿ƒæ•°æ®ä¸çŠ¶æ€ç®¡ç† ---

        // --- éŸ³æ•ˆç³»ç»Ÿï¼šå·´èµ« Cello Suite No.1 PrÃ©lude ---
        let audioCtx = null;
        let preludeIndex = 0;
        const preludeNotes = [
            // Measure 1-2: G major arpeggio pattern
            98.00, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            98.00, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            // Measure 3-4: C major / Am
            110.00, 164.81, 261.63, 246.94, 261.63, 164.81, 261.63, 164.81,
            110.00, 164.81, 261.63, 246.94, 261.63, 164.81, 261.63, 164.81,
            // Measure 5-6: D major
            123.47, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            130.81, 164.81, 220.00, 196.00, 220.00, 164.81, 220.00, 164.81,
            // Measure 7-8: G -> D7
            123.47, 146.83, 196.00, 174.61, 196.00, 146.83, 196.00, 146.83,
            98.00, 123.47, 174.61, 146.83, 174.61, 123.47, 174.61, 123.47,
            // Measure 9-10
            98.00, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            98.00, 164.81, 261.63, 246.94, 261.63, 164.81, 261.63, 164.81,
            // Measure 11-12: rising line
            110.00, 185.00, 293.66, 261.63, 293.66, 185.00, 293.66, 185.00,
            146.83, 220.00, 293.66, 261.63, 293.66, 220.00, 293.66, 220.00,
        ];

        function ensureAudioCtx() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playCelloNote(freq, duration = 0.25) {
            ensureAudioCtx();
            const t = audioCtx.currentTime;

            // åŸºé¢‘ + æ³›éŸ³æ¨¡æ‹Ÿå¤§æç´
            const gains = [1, 0.5, 0.3, 0.15, 0.08];
            const masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(0, t);
            masterGain.gain.linearRampToValueAtTime(0.15, t + 0.02);
            masterGain.gain.setValueAtTime(0.15, t + duration * 0.5);
            masterGain.gain.exponentialRampToValueAtTime(0.001, t + duration);
            masterGain.connect(audioCtx.destination);

            gains.forEach((g, i) => {
                const osc = audioCtx.createOscillator();
                const oscGain = audioCtx.createGain();
                osc.type = i === 0 ? 'sawtooth' : 'triangle';
                osc.frequency.setValueAtTime(freq * (i + 1), t);
                oscGain.gain.setValueAtTime(g * 0.3, t);
                osc.connect(oscGain);
                oscGain.connect(masterGain);
                osc.start(t);
                osc.stop(t + duration + 0.05);
            });
        }

        function playCorrectNote() {
            const freq = preludeNotes[preludeIndex % preludeNotes.length];
            preludeIndex++;
            playCelloNote(freq, 0.22);
        }

        function playWrongNote() {
            ensureAudioCtx();
            playCelloNote(73.42, 0.35); // D2 ä½æ²‰
        }

        function playCompleteChord() {
            playCelloNote(196.00, 0.5);
            setTimeout(() => playCelloNote(246.94, 0.5), 80);
            setTimeout(() => playCelloNote(293.66, 0.6), 160);
        }

        function playAutoClick() {
            ensureAudioCtx();
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = 1200;
            gain.gain.setValueAtTime(0.03, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.04);
        }

        function speakWordPhrase(text) {
            if (!('speechSynthesis' in window)) return;
            const value = String(text || '').trim();
            if (!value) return;
            const spoken = value
                .replace(/\bsth\./gi, 'something')
                .replace(/\bsb\./gi, 'somebody');
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(spoken);
            utterance.lang = 'en-US';
            utterance.rate = 0.95;
            utterance.pitch = 1;
            utterance.volume = 1;
            window.speechSynthesis.speak(utterance);
        }

        let dictionaries = {};
        
        let currentDictionary = null;
        let currentDictName = '';

        function getLearningProgress(dictName) {
            const saved = localStorage.getItem('wordVineProgress');
            if (!saved) return {};
            try {
                const all = JSON.parse(saved);
                return all[dictName] || {};
            } catch(e) { return {}; }
        }

        function markWordLearned(dictName, word) {
            let all = {};
            const saved = localStorage.getItem('wordVineProgress');
            if (saved) { try { all = JSON.parse(saved); } catch(e) {} }
            if (!all[dictName]) all[dictName] = {};
            all[dictName][word] = Date.now();
            localStorage.setItem('wordVineProgress', JSON.stringify(all));
        }

        function getLearnedCount(dictName) {
            const prog = getLearningProgress(dictName);
            return Object.keys(prog).length;
        }

        function clearLearningProgress(dictName) {
            let all = {};
            const saved = localStorage.getItem('wordVineProgress');
            if (saved) { try { all = JSON.parse(saved); } catch(e) {} }
            delete all[dictName];
            localStorage.setItem('wordVineProgress', JSON.stringify(all));
        }

        // åŠ è½½æœ¬åœ°ç¼“å­˜çš„è¯åº“
        function loadDictionaries() {
            const saved = localStorage.getItem('wordVineDicts');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    dictionaries = parsed;
                } catch (e) {
                    console.error("Failed to load dictionaries", e);
                }
            }
            updateDictSelect();
        }

        // æ›´æ–°ä¸‹æ‹‰èœå•
        function updateDictSelect() {
            const select = document.getElementById('dictSelect');
            select.innerHTML = '';
            for (const name in dictionaries) {
                const option = document.createElement('option');
                option.value = name;
                const learned = getLearnedCount(name);
                const total = dictionaries[name].length;
                option.textContent = `${name} (${learned}/${total})`;
                select.appendChild(option);
            }
        }

        // å¯¼å…¥æ–°è¯åº“
        document.getElementById('importBtn').addEventListener('click', () => {
            const nameInput = document.getElementById('dictNameInput').value.trim();
            const dataInput = document.getElementById('importData').value.trim();
            const msgDiv = document.getElementById('importMsg');
            
            if (!nameInput) {
                msgDiv.textContent = "è¯·è¾“å…¥è¯åº“åç§°";
                msgDiv.style.color = "#f44336";
                return;
            }
            if (!dataInput) {
                msgDiv.textContent = "è¯·è¾“å…¥JSONæ•°æ®";
                msgDiv.style.color = "#f44336";
                return;
            }

            try {
                const parsedData = JSON.parse(dataInput);
                const newDict = [];
                
                // éªŒè¯å¹¶è½¬æ¢æ ¼å¼
                for (const key in parsedData) {
                    if (typeof key === 'string' && typeof parsedData[key] === 'string') {
                        const trimmed = key.trim();
                        if (trimmed.length > 0 && /[a-zA-Z]/.test(trimmed)) {
                            newDict.push({ word: trimmed, meaning: parsedData[key] });
                        }
                    }
                }

                if (newDict.length === 0) {
                    throw new Error("æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„å•è¯æ•°æ®");
                }

                // ä¿å­˜åˆ°å†…å­˜å’Œ localStorage
                dictionaries[nameInput] = newDict;
                
                localStorage.setItem('wordVineDicts', JSON.stringify(dictionaries));
                
                updateDictSelect();
                
                // é€‰ä¸­æ–°å¯¼å…¥çš„è¯åº“
                document.getElementById('dictSelect').value = nameInput;
                
                msgDiv.textContent = `æˆåŠŸå¯¼å…¥ ${newDict.length} ä¸ªå•è¯ï¼`;
                msgDiv.style.color = "#4CAF50";
                
                // æ¸…ç©ºè¾“å…¥æ¡†
                document.getElementById('dictNameInput').value = '';
                document.getElementById('importData').value = '';
                
            } catch (e) {
                msgDiv.textContent = "JSON æ ¼å¼é”™è¯¯æˆ–æ•°æ®æ— æ•ˆ: " + e.message;
                msgDiv.style.color = "#f44336";
            }
        });

        // ä»æ–‡ä»¶åŠ è½½
        document.getElementById('loadFileBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    // å°è¯•è§£æä»¥éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆ JSON
                    JSON.parse(content);
                    
                    // å¡«å……åˆ°æ–‡æœ¬æ¡†
                    document.getElementById('importData').value = content;
                    
                    // å¦‚æœæ²¡æœ‰è¾“å…¥åç§°ï¼Œä½¿ç”¨æ–‡ä»¶åï¼ˆå»æ‰æ‰©å±•åï¼‰
                    const nameInput = document.getElementById('dictNameInput');
                    if (!nameInput.value) {
                        nameInput.value = file.name.replace(/\.[^/.]+$/, "");
                    }
                    
                    document.getElementById('importMsg').textContent = "æ–‡ä»¶åŠ è½½æˆåŠŸï¼Œè¯·ç‚¹å‡»'ä¿å­˜å¹¶å¯¼å…¥'";
                    document.getElementById('importMsg').style.color = "#4CAF50";
                } catch (err) {
                    document.getElementById('importMsg').textContent = "æ–‡ä»¶å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼";
                    document.getElementById('importMsg').style.color = "#f44336";
                }
                // æ¸…ç©º input ä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
                event.target.value = '';
            };
            reader.readAsText(file);
        });

        // åˆ é™¤è¯åº“
        document.getElementById('deleteDictBtn').addEventListener('click', () => {
            const selectedName = document.getElementById('dictSelect').value;
            if (!selectedName) {
                alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè¯åº“ï¼");
                return;
            }
            const input = prompt(`åˆ é™¤è¯åº“ "${selectedName}" åæ— æ³•æ¢å¤ï¼\nè¯·è¾“å…¥â€œç¡®è®¤â€ä»¥ç»§ç»­ï¼š`);
            if (input !== 'ç¡®è®¤') return;
            delete dictionaries[selectedName];
            localStorage.setItem('wordVineDicts', JSON.stringify(dictionaries));
            clearLearningProgress(selectedName);
            updateDictSelect();
        });

        // é‡ç½®è¯åº“å­¦ä¹ è®°å½•
        document.getElementById('resetDictBtn').addEventListener('click', () => {
            const selectedName = document.getElementById('dictSelect').value;
            const input = prompt(`å°†æ¸…é™¤è¯åº“ "${selectedName}" çš„æ‰€æœ‰å­¦ä¹ è®°å½•ï¼\nè¯·è¾“å…¥â€œç¡®è®¤â€ä»¥ç»§ç»­ï¼š`);
            if (input !== 'ç¡®è®¤') return;
            dailyStats.wordsCompleted = 0;
            dailyStats.mistakes = 0;
            dailyStats.deaths = 0;
            saveDailyStats();
            gameState.historicalMistakes = {};
            gameState.wordMistakeMap = {};
            clearLearningProgress(selectedName);
            updateDictSelect();
            alert(`è¯åº“ "${selectedName}" çš„å­¦ä¹ è®°å½•å·²é‡ç½®ï¼`);
        });

        // å¼€å§‹æ¸¸æˆæŒ‰é’®
        document.getElementById('startBtn').addEventListener('click', () => {
            const selectedName = document.getElementById('dictSelect').value;
            if (!selectedName || !dictionaries[selectedName]) {
                alert("è¯·å…ˆå¯¼å…¥ä¸€ä¸ªè¯åº“ï¼");
                return;
            }
            currentDictName = selectedName;
            const fullDict = dictionaries[selectedName];
            const progress = getLearningProgress(selectedName);
            currentDictionary = fullDict.filter(item => !progress[item.word]);
            
            if (currentDictionary.length === 0) {
                alert("è¯¥è¯åº“æ‰€æœ‰å•è¯å·²å­¦å®Œï¼å¯ä»¥é‡ç½®å­¦ä¹ è®°å½•é‡æ–°å¼€å§‹ã€‚");
                return;
            }
            
            currentDictionary.sort(() => Math.random() - 0.5);
            
            document.getElementById('menuLayer').classList.add('hidden');
            document.getElementById('uiLayer').classList.remove('hidden');
            
            initGame();
            if (!gameLoopRunning) {
                gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        });

        const gameState = {
            currentWordIndex: 0,
            currentStepIndex: 0,
            score: 0,
            combo: 1,
            cameraY: 0,
            targetCameraY: 0,
            cameraX: 0,
            targetCameraX: 0,
            cameraZoom: 1,
            targetCameraZoom: 1,
            bgHue: 120, // åˆå§‹ç»¿è‰²è‰²ç›¸
            targetBgHue: 120,
            isTransitioning: false, // æ˜¯å¦åœ¨å•è¯åˆ‡æ¢çš„è¿‡æ¸¡æœŸ
            isSettling: false, // æ˜¯å¦åœ¨ç°‡ç»“ç®—çŠ¶æ€
            isPromptingMemo: false, // æ˜¯å¦åœ¨è¯¢é—®å¿«é€Ÿè®°å¿†
            isShowingMemo: false, // æ˜¯å¦åœ¨å±•ç¤ºå¿«é€Ÿè®°å¿†
            nodes: [], // å­˜å‚¨è—¤è”“ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹
            activeOptions: [], // å½“å‰å±å¹•ä¸Šå¯ä¾›é€‰æ‹©çš„èŠ‚ç‚¹ï¼ˆæ­£ç¡®+å¹²æ‰°ï¼‰
            fadingNodes: [], // æ­£åœ¨æ·¡å‡ºçš„é”™è¯¯èŠ‚ç‚¹
            mistakeCount: 0,
            lastMistakeTime: 0,
            currentWordStartIndex: 0,
            clusterSize: 10, // æ¯ä¸ªç°‡çš„å•è¯æ•°é‡
            wordsCompletedInCluster: 0,
            clusterMistakes: 0, // å½“å‰ç°‡çš„æ€»é”™è¯¯æ•°
            historicalMistakes: {}, // è®°å½•æ›¾é€‰é”™çš„å­—æ¯ {word: [wrongLetters]}
            wordMistakeMap: {}, // è®°å½•æ¯ä¸ªå•è¯çš„é”™è¯¯æ¬¡æ•°ï¼Œç”¨äºæ‰æ ¹æŒ‘æˆ˜
            wordLabels: [],
            labelHitAreas: [],
            parsedSteps: [],
            isAutoDrawing: false,
            isDragging: false,
            dragStartY: 0,
            dragStartCameraY: 0,
            dragMoved: false,
            isBrowsing: false
        };

        gameStateReady = true;

        function adjustTreePositionOnResize(prevW, prevH, nextW, nextH) {
            const dx = (nextW - prevW) * 0.5;
            const dy = (nextH - prevH) * 0.5;
            if (dx === 0 && dy === 0) return;

            const shiftNodes = (arr) => {
                arr.forEach(node => {
                    node.x += dx;
                    node.y += dy;
                });
            };

            shiftNodes(gameState.nodes);
            shiftNodes(gameState.activeOptions);
            shiftNodes(gameState.fadingNodes);

            gameState.wordLabels.forEach(label => {
                label.x += dx;
                label.y += dy;
            });
        }

        const dailyStats = {
            date: new Date().toDateString(),
            wordsCompleted: 0,
            mistakes: 0,
            deaths: 0
        };

        function loadDailyStats() {
            const saved = localStorage.getItem('wordVineDailyStats');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (parsed.date === new Date().toDateString()) {
                        dailyStats.wordsCompleted = parsed.wordsCompleted || 0;
                        dailyStats.mistakes = parsed.mistakes || 0;
                        dailyStats.deaths = parsed.deaths || 0;
                    }
                } catch(e) {}
            }
        }

        function saveDailyStats() {
            dailyStats.date = new Date().toDateString();
            localStorage.setItem('wordVineDailyStats', JSON.stringify(dailyStats));
        }

        function showDailyStats() {
            const overlay = document.getElementById('dailyStatsOverlay');
            document.getElementById('statWords').innerText = dailyStats.wordsCompleted;
            document.getElementById('statMistakes').innerText = dailyStats.mistakes;
            document.getElementById('statDeaths').innerText = dailyStats.deaths;
            overlay.classList.remove('hidden');
            gameState.isTransitioning = true;
        }

        function hideDailyStats() {
            document.getElementById('dailyStatsOverlay').classList.add('hidden');
            gameState.isTransitioning = false;
        }

        function confirmExit() {
            const ok = confirm('ç¡®å®šé€€å‡ºåˆ°ä¸»ç•Œé¢å—ï¼Ÿå½“å‰è¿›åº¦å·²è‡ªåŠ¨ä¿å­˜ã€‚');
            if (!ok) return;
            gameLoopRunning = false;
            document.getElementById('uiLayer').classList.add('hidden');
            document.getElementById('menuLayer').classList.remove('hidden');
            updateDictSelect();
        }

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(x, y, letter, isCorrect, parent = null) {
                this.x = x;
                this.y = y;
                this.letter = letter;
                this.isCorrect = isCorrect;
                this.parent = parent;
                this.state = 'active';
                this.radius = 20;
                this.alpha = 1;
                this.scale = 0;
                this.targetScale = 1;
                this.nodeType = 'letter';
            }

            update(dt) {
                // ç®€å•çš„å¼¹æ€§åŠ¨ç”»
                this.scale += (this.targetScale - this.scale) * 0.1;
                
                if (this.state === 'fading') {
                    this.alpha -= 0.05;
                    if (this.alpha <= 0) {
                        this.alpha = 0;
                    }
                }
            }
        }

        const CAPSULE_PLACEHOLDERS = ['sth.', 'sb.', 'adj.', 'adv.', 'prep.', 'pron.', 'conj.'];

        function formatWord(w) {
            if (!w) return '';
            return w.split(' ').map(part => {
                if (CAPSULE_PLACEHOLDERS.includes(part.toLowerCase())) return part.toLowerCase();
                if (part.length === 0) return part;
                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
            }).join(' ');
        }

        function parsePhrase(phrase) {
            const steps = [];
            let i = 0;
            const sorted = [...CAPSULE_PLACEHOLDERS].sort((a, b) => b.length - a.length);
            while (i < phrase.length) {
                let found = false;
                for (const ph of sorted) {
                    const sub = phrase.substring(i, i + ph.length);
                    if (sub.toLowerCase() === ph.toLowerCase()) {
                        const before = i === 0 || !/[a-zA-Z]/.test(phrase[i - 1]);
                        const after = i + ph.length >= phrase.length || !/[a-zA-Z]/.test(phrase[i + ph.length]);
                        if (before && after) {
                            steps.push({ type: 'auto', display: sub, subType: 'capsule' });
                            i += ph.length;
                            found = true;
                            break;
                        }
                    }
                }
                if (found) continue;
                if (phrase[i] === '(') {
                    const close = phrase.indexOf(')', i);
                    if (close !== -1) {
                        steps.push({ type: 'auto', display: phrase.substring(i, close + 1), subType: 'bracket' });
                        i = close + 1;
                        continue;
                    }
                }
                if (/[a-zA-Z]/.test(phrase[i])) {
                    steps.push({ type: 'input', char: phrase[i].toUpperCase(), displayChar: phrase[i].toLowerCase() });
                    i++;
                } else if (phrase[i] === ' ') {
                    steps.push({ type: 'auto', display: ' ', subType: 'space' });
                    i++;
                } else {
                    steps.push({ type: 'auto', display: phrase[i], subType: 'symbol' });
                    i++;
                }
            }
            return steps;
        }

        function advanceAfterStep(parentNode) {
            const nextIdx = gameState.currentStepIndex + 1;
            if (nextIdx >= gameState.parsedSteps.length) {
                completeWord();
                return;
            }
            if (gameState.parsedSteps[nextIdx].type === 'auto') {
                processAutoSteps(parentNode);
            } else {
                generateOptions(parentNode);
            }
        }

        function processAutoSteps(parentNode) {
            gameState.isAutoDrawing = true;
            gameState.activeOptions = [];
            const autoSteps = [];
            let idx = gameState.currentStepIndex + 1;
            while (idx < gameState.parsedSteps.length && gameState.parsedSteps[idx].type === 'auto') {
                autoSteps.push({ step: gameState.parsedSteps[idx], idx });
                idx++;
            }
            let current = parentNode;
            let delay = 0;
            autoSteps.forEach((item, i) => {
                delay += item.step.subType === 'space' ? 80 : 150;
                setTimeout(() => {
                    const dist = item.step.subType === 'space' ? 40 : 55;
                    let x = current.x + (Math.random() - 0.5) * 15;
                    const y = current.y - dist;
                    const margin = 40;
                    x = Math.max(margin, Math.min(width - margin, x));
                    const node = new Node(x, y, item.step.display, true, current);
                    node.state = 'completed';
                    node.nodeType = item.step.subType;
                    node.scale = 0;
                    node.targetScale = 1;
                    gameState.nodes.push(node);
                    gameState.currentStepIndex = item.idx;
                    current = node;
                    gameState.targetCameraY = height * 0.5 - node.y;
                    gameState.targetCameraX = width * 0.5 - node.x;
                    playAutoClick();
                    if (i === autoSteps.length - 1) {
                        gameState.isAutoDrawing = false;
                        const next = gameState.parsedSteps[gameState.currentStepIndex + 1];
                        if (next && next.type === 'input') {
                            generateOptions(node);
                        } else if (!next) {
                            completeWord();
                        }
                        updateUI();
                    }
                }, delay);
            });
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameState.currentWordIndex = 0;
            gameState.currentStepIndex = 0;
            gameState.score = 0;
            gameState.combo = 1;
            gameState.nodes = [];
            gameState.activeOptions = [];
            gameState.fadingNodes = [];
            gameState.mistakeCount = 0;
            gameState.lastMistakeTime = 0;
            gameState.currentWordStartIndex = 0;
            gameState.wordsCompletedInCluster = 0;
            gameState.clusterMistakes = 0;
            gameState.historicalMistakes = {};
            gameState.wordMistakeMap = {};
            gameState.wordLabels = [];
            gameState.cameraZoom = 1;
            gameState.targetCameraZoom = 1;
            gameState.bgHue = 120;
            gameState.targetBgHue = 120;
            gameState.isSettling = false;
            gameState.isAutoDrawing = false;
            gameState.isPromptingMemo = false;
            gameState.isShowingMemo = false;
            
            promptQuickMemo();
        }

        function startGameplay() {
            const firstPhrase = currentDictionary[gameState.currentWordIndex].word;
            gameState.parsedSteps = parsePhrase(firstPhrase);
            gameState.currentStepIndex = 0;

            const firstStep = gameState.parsedSteps[0];
            const rootNode = new Node(width / 2, height * 0.8, firstStep.char, true);
            rootNode.state = 'completed';
            rootNode.scale = 1;
            gameState.nodes.push(rootNode);
            
            gameState.cameraY = 0;
            gameState.targetCameraY = 0;
            gameState.cameraX = 0;
            gameState.targetCameraX = 0;

            advanceAfterStep(rootNode);
            updateUI();
            initProgressGauge();
        }

        function initProgressGauge() {
            const gauge = document.getElementById('progressGauge');
            gauge.innerHTML = '';
            for (let i = 0; i < gameState.clusterSize; i++) {
                const dot = document.createElement('div');
                dot.className = 'gauge-dot';
                if (i === 0) dot.classList.add('current');
                gauge.appendChild(dot);
            }
        }

        function updateProgressGauge() {
            const dots = document.querySelectorAll('.gauge-dot');
            dots.forEach((dot, index) => {
                dot.className = 'gauge-dot'; // reset
                if (index < gameState.wordsCompletedInCluster) {
                    dot.classList.add('completed');
                } else if (index === gameState.wordsCompletedInCluster) {
                    dot.classList.add('current');
                }
            });
            
            // æ›´æ–°æ–‡å­—è¿›åº¦
            const totalWords = dictionaries[currentDictName] ? dictionaries[currentDictName].length : currentDictionary.length;
            const learnedWords = getLearnedCount(currentDictName);
            document.getElementById('progressDisplay').innerText = `${learnedWords}/${totalWords}`;
        }

        // --- æ¸¸æˆä¸»å¾ªç¯ ---
        let lastTime = 0;
        let gameLoopRunning = false;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            if (gameLoopRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        function update(dt) {
            if (!gameState.isDragging && !gameState.isBrowsing) {
                gameState.cameraY += (gameState.targetCameraY - gameState.cameraY) * 0.1;
            }
            gameState.cameraX += (gameState.targetCameraX - gameState.cameraX) * 0.1;
            gameState.cameraZoom += (gameState.targetCameraZoom - gameState.cameraZoom) * 0.05;
            gameState.bgHue += (gameState.targetBgHue - gameState.bgHue) * 0.02;

            // æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€
            gameState.nodes.forEach(node => node.update(dt));
            gameState.activeOptions.forEach(node => node.update(dt));
            gameState.fadingNodes.forEach(node => node.update(dt));
            
            // æ¸…ç†å®Œå…¨é€æ˜çš„èŠ‚ç‚¹
            gameState.fadingNodes = gameState.fadingNodes.filter(node => node.alpha > 0);
        }

        function draw() {
            // æ¸…ç©ºç”»å¸ƒï¼Œä½¿ç”¨åŠ¨æ€è‰²ç›¸
            ctx.fillStyle = `hsl(${gameState.bgHue}, 20%, 8%)`;
            ctx.fillRect(0, 0, width, height);
            
            // ç»˜åˆ¶åŠ¨æ€èƒŒæ™¯ç½‘æ ¼
            drawGrid();

            // åº”ç”¨ç›¸æœºå˜æ¢
            ctx.save();
            
            // ç¼©æ”¾ä¸­å¿ƒç‚¹ä¸ºå±å¹•ä¸­å¿ƒ
            ctx.translate(width / 2, height / 2);
            ctx.scale(gameState.cameraZoom, gameState.cameraZoom);
            ctx.translate(-width / 2, -height / 2);
            
            ctx.translate(gameState.cameraX, gameState.cameraY);

            // ç»˜åˆ¶è—¤è”“å’ŒèŠ‚ç‚¹
            drawVines();
            drawNodes();

            ctx.restore();

            if (gameState.isBrowsing) {
                const btnW = 120, btnH = 40;
                const btnX = (width - btnW) / 2;
                const btnY = height - 60;
                ctx.fillStyle = 'rgba(76, 175, 80, 0.85)';
                ctx.beginPath();
                ctx.roundRect(btnX, btnY, btnW, btnH, 8);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 15px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('å›åˆ°å½“å‰', btnX + btnW / 2, btnY + btnH / 2);
                gameState._backBtnRect = { x: btnX, y: btnY, w: btnW, h: btnH };
            }
        }

        function drawGrid() {
            const gridSize = 50;
            const offsetX = 0;
            // åˆ©ç”¨å–æ¨¡è¿ç®—å®ç°æ— é™æ»šåŠ¨é”™è§‰
            const offsetY = gameState.cameraY % gridSize;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();

            // å‚ç›´çº¿
            for (let x = offsetX; x < width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }

            // æ°´å¹³çº¿
            for (let y = offsetY; y < height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }

            ctx.stroke();
        }

        function drawVines() {
            // ç»˜åˆ¶å·²å®Œæˆçš„è·¯å¾„ï¼ˆç²—å®çº¿ï¼Œå‘å…‰ï¼‰
            ctx.beginPath();
            ctx.strokeStyle = '#4CAF50'; // ç»¿è‰²è—¤è”“
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#4CAF50';

            if (gameState.nodes.length > 0) {
                ctx.moveTo(gameState.nodes[0].x, gameState.nodes[0].y);
                for (let i = 1; i < gameState.nodes.length; i++) {
                    const node = gameState.nodes[i];
                    
                    if (node.isNewTreeRoot) {
                        ctx.moveTo(node.x, node.y);
                    } else {
                        const prevNode = gameState.nodes[i - 1];
                        if (node.nodeType === 'space') {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([4, 6]);
                            ctx.lineWidth = 2;
                            ctx.moveTo(prevNode.x, prevNode.y);
                            ctx.lineTo(node.x, node.y);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([]);
                            ctx.lineWidth = 6;
                            ctx.moveTo(node.x, node.y);
                        } else {
                            const cpX = (prevNode.x + node.x) / 2;
                            const cpY = prevNode.y - 30;
                            ctx.quadraticCurveTo(cpX, cpY, node.x, node.y);
                        }
                    }
                }
            }
            ctx.stroke();
            
            // é‡ç½®é˜´å½±
            ctx.shadowBlur = 0;

            // ç»˜åˆ¶å½“å‰åˆ†æ”¯ï¼ˆç»†è™šçº¿ï¼ŒåŠé€æ˜ï¼‰
            if (gameState.nodes.length > 0 && !gameState.isTransitioning) {
                const lastNode = gameState.nodes[gameState.nodes.length - 1];
                
                gameState.activeOptions.forEach(option => {
                    ctx.beginPath();
                    if (option.state === 'wrong') {
                        ctx.strokeStyle = `rgba(244, 67, 54, ${option.alpha})`; // çº¢è‰²é”™è¯¯è·¯å¾„
                        ctx.setLineDash([]);
                    } else {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${option.alpha * 0.3})`; // ç™½è‰²è™šçº¿
                        ctx.setLineDash([5, 5]);
                    }
                    ctx.lineWidth = 2;
                    
                    const cpX = (lastNode.x + option.x) / 2;
                    const cpY = lastNode.y - 30;
                    ctx.moveTo(lastNode.x, lastNode.y);
                    ctx.quadraticCurveTo(cpX, cpY, option.x, option.y);
                    ctx.stroke();
                });
                ctx.setLineDash([]); // æ¢å¤å®çº¿
            }
        }

        function drawNodes() {
            gameState.labelHitAreas = [];

            gameState.nodes.forEach((node, index) => {
                const isLastNodeOfWord = index > 0 && (index === gameState.nodes.length - 1 || gameState.nodes[index + 1].isNewTreeRoot);
                if (isLastNodeOfWord && node.state === 'completed' && node.nodeType === 'letter') {
                    drawBloom(node);
                } else {
                    drawSingleNode(node, '#4CAF50', '#fff');
                }
            });
            
            // ç»˜åˆ¶å•è¯æ ‡ç­¾
            gameState.wordLabels.forEach(label => {
                const wordText = formatWord(label.word);
                const iconText = 'ğŸ”Š';
                const textX = label.x + 30;
                const wordY = label.y - 8;
                const meaningY = label.y + 10;

                ctx.save();
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.7)';
                ctx.fillText(wordText, textX, wordY);
                const wordWidth = ctx.measureText(wordText).width;

                ctx.font = '13px sans-serif';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.65)';
                ctx.fillText(iconText, textX + wordWidth + 8, wordY + 1);
                const iconWidth = ctx.measureText(iconText).width;

                ctx.font = '12px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText(label.meaning, textX, meaningY);
                const meaningWidth = ctx.measureText(label.meaning).width;
                ctx.restore();

                gameState.labelHitAreas.push({
                    x: textX - 4,
                    y: wordY - 12,
                    w: Math.max(wordWidth + 8 + iconWidth, meaningWidth) + 8,
                    h: 32,
                    word: label.word
                });
            });
            
            // ç»˜åˆ¶æ­£åœ¨æ·¡å‡ºçš„é”™è¯¯èŠ‚ç‚¹
            gameState.fadingNodes.forEach(node => {
                drawSingleNode(node, `rgba(244, 67, 54, ${node.alpha})`, '#fff', node.alpha);
            });
            
            // ç»˜åˆ¶é€‰é¡¹èŠ‚ç‚¹
            if (!gameState.isTransitioning && !gameState.isSettling) {
                gameState.activeOptions.forEach(node => {
                    let bgColor = 'rgba(255, 255, 255, 0.1)';
                    let textColor = `rgba(255, 255, 255, ${node.alpha})`;
                    
                    if (node.state === 'wrong') {
                        bgColor = `rgba(244, 67, 54, ${node.alpha})`;
                        textColor = '#fff';
                    }
                    
                    drawSingleNode(node, bgColor, textColor, node.alpha);
                });
            }
        }

        function drawBloom(node) {
            ctx.save();
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);

            // ç»˜åˆ¶å‡ ä½•èŠ±è‹ (ç®€å•çš„å¤šè¾¹å½¢)
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(15, -10);
            ctx.lineTo(10, 15);
            ctx.lineTo(-10, 15);
            ctx.lineTo(-15, -10);
            ctx.closePath();
            
            ctx.fillStyle = '#8BC34A'; // æµ…ç»¿è‰²èŠ±è‹
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            
            // ç»˜åˆ¶å­—æ¯
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.letter, 0, 2);

            ctx.restore();
        }

        function drawSingleNode(node, bgColor, textColor, alpha = 1) {
            if (node.nodeType === 'capsule') { drawCapsuleNode(node, alpha); return; }
            if (node.nodeType === 'bracket') { drawBracketNode(node, alpha); return; }
            if (node.nodeType === 'symbol') { drawSymbolNode(node, alpha); return; }
            if (node.nodeType === 'space') return;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);

            ctx.beginPath();
            ctx.arc(0, 0, node.radius, 0, Math.PI * 2);
            ctx.fillStyle = bgColor;
            ctx.fill();
            
            if (node.state === 'completed') {
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#fff';
                ctx.stroke();
            }

            ctx.fillStyle = textColor;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.letter, 0, 2);

            ctx.restore();
        }

        function drawCapsuleNode(node, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);
            const text = node.letter;
            ctx.font = 'bold 11px Courier New';
            const tw = ctx.measureText(text).width;
            const pad = 10;
            const w = tw + pad * 2;
            const h = 22;
            ctx.beginPath();
            ctx.roundRect(-w / 2, -h / 2, w, h, h / 2);
            ctx.fillStyle = 'rgba(139,195,74,0.25)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(139,195,74,0.6)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#8BC34A';
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#8BC34A';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }

        function drawSymbolNode(node, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.letter, 0, 0);
            ctx.restore();
        }

        function drawBracketNode(node, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha * 0.6;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);
            const text = node.letter;
            ctx.font = '11px Courier New';
            const tw = ctx.measureText(text).width;
            const pad = 8;
            const w = tw + pad * 2;
            const h = 20;
            ctx.beginPath();
            ctx.roundRect(-w / 2, -h / 2, w, h, 4);
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.45)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }

        // --- 5. åŒæ¨¡è¾“å…¥ä¸æ ¸å¿ƒæœºåˆ¶ ---
        function screenToWorld(screenX, screenY) {
            const centerX = width / 2;
            const centerY = height / 2;
            const z = gameState.cameraZoom || 1;
            return {
                x: ((screenX - centerX) / z) + centerX - gameState.cameraX,
                y: ((screenY - centerY) / z) + centerY - gameState.cameraY
            };
        }

        window.addEventListener('keydown', (e) => {
            // å¤„ç†å¿«é€Ÿè®°å¿†è¯¢é—®ç•Œé¢çš„é”®ç›˜äº‹ä»¶
            if (gameState.isPromptingMemo) {
                if (e.key.toUpperCase() === 'Y') {
                    showQuickMemo();
                } else if (e.key.toUpperCase() === 'N' || e.key === 'Escape') {
                    dismissQuickMemo();
                }
                return;
            }
            
            // å¤„ç†å¿«é€Ÿè®°å¿†å±•ç¤ºç•Œé¢çš„é”®ç›˜äº‹ä»¶
            if (gameState.isShowingMemo) {
                if (e.key === ' ' || e.key === 'Escape' || e.key === 'Enter') {
                    e.preventDefault();
                    dismissQuickMemo();
                }
                return;
            }
            
            if (gameState.isTransitioning || gameState.isSettling || gameState.isAutoDrawing) return;
            
            const pressedKey = e.key.toUpperCase();
            
            // å¤„ç†é€€æ ¼é”®ä¿®å‰ª
            if (e.key === 'Backspace') {
                e.preventDefault();
                pruneNode();
                return;
            }

            // ä»…å¤„ç†å­—æ¯é”®
            if (!/^[A-Z]$/.test(pressedKey)) return;

            handleInput(pressedKey);
        });

        canvas.addEventListener('pointerdown', (e) => {
            gameState.isDragging = true;
            gameState.dragStartY = e.clientY;
            gameState.dragStartCameraY = gameState.cameraY;
            gameState.dragMoved = false;
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!gameState.isDragging) return;
            const dy = e.clientY - gameState.dragStartY;
            if (Math.abs(dy) > 5) {
                gameState.dragMoved = true;
                gameState.cameraY = gameState.dragStartCameraY + dy;
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            if (gameState.isDragging && !gameState.dragMoved) {
                if (gameState.isBrowsing && gameState._backBtnRect) {
                    const rect2 = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect2.left;
                    const my = e.clientY - rect2.top;
                    const b = gameState._backBtnRect;
                    if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
                        const lastNode = gameState.nodes[gameState.nodes.length - 1];
                        if (lastNode) {
                            gameState.targetCameraY = height * 0.5 - lastNode.y;
                        }
                        gameState.isBrowsing = false;
                        gameState.isDragging = false;
                        gameState.dragMoved = false;
                        return;
                    }
                }
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPoint = screenToWorld(mouseX, mouseY);

                for (let i = gameState.labelHitAreas.length - 1; i >= 0; i--) {
                    const area = gameState.labelHitAreas[i];
                    if (worldPoint.x >= area.x && worldPoint.x <= area.x + area.w && worldPoint.y >= area.y && worldPoint.y <= area.y + area.h) {
                        speakWordPhrase(area.word);
                        gameState.isDragging = false;
                        gameState.dragMoved = false;
                        return;
                    }
                }

                if (!gameState.isTransitioning && !gameState.isAutoDrawing) {
                    const clickX = worldPoint.x;
                    const clickY = worldPoint.y;

                    for (let i = 0; i < gameState.activeOptions.length; i++) {
                        const option = gameState.activeOptions[i];
                        const dx = clickX - option.x;
                        const dy2 = clickY - option.y;
                        const distance = Math.sqrt(dx * dx + dy2 * dy2);
                        if (distance <= option.radius * 1.5) {
                            handleInput(option.letter);
                            break;
                        }
                    }
                }
            } else if (gameState.dragMoved) {
                gameState.isBrowsing = true;
            }
            gameState.isDragging = false;
            gameState.dragMoved = false;
        });

        canvas.addEventListener('pointerleave', () => {
            if (gameState.isDragging && gameState.dragMoved) {
                gameState.isBrowsing = true;
            }
            gameState.isDragging = false;
            gameState.dragMoved = false;
        });

        function handleInput(letter) {
            const nextIdx = gameState.currentStepIndex + 1;
            if (nextIdx >= gameState.parsedSteps.length) return;
            const nextStep = gameState.parsedSteps[nextIdx];
            if (nextStep.type !== 'input') return;
            const correctLetter = nextStep.char;

            const selectedOption = gameState.activeOptions.find(opt => opt.letter === letter);

            if (selectedOption) {
                if (gameState.isBrowsing) {
                    gameState.isBrowsing = false;
                    const currentNode = gameState.nodes[gameState.nodes.length - 1];
                    if (currentNode) {
                        gameState.targetCameraY = height * 0.5 - currentNode.y;
                        gameState.targetCameraX = width * 0.5 - currentNode.x;
                    }
                }
                if (selectedOption.isCorrect) {
                    advanceNode(selectedOption);
                } else {
                    handleMistake(selectedOption);
                }
            }
        }

        function advanceNode(selectedOption) {
            playCorrectNote();
            const margin = 40;
            selectedOption.x = Math.max(margin, Math.min(width - margin, selectedOption.x));
            
            selectedOption.state = 'completed';
            selectedOption.scale = 1.2;
            setTimeout(() => selectedOption.targetScale = 1, 100);
            gameState.nodes.push(selectedOption);

            gameState.currentStepIndex++;
            gameState.score += 10 * gameState.combo;
            gameState.combo++;
            gameState.mistakeCount = 0;
            updateUI();

            gameState.targetCameraY = height * 0.5 - selectedOption.y;
            gameState.targetCameraX = width * 0.5 - selectedOption.x;

            advanceAfterStep(selectedOption);
        }

        function handleMistake(wrongOption) {
            playWrongNote();
            const now = Date.now();
            
            // è®°å½•å•è¯é”™è¯¯æ¬¡æ•°
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            const wordKey = currentWordObj.word;
            gameState.wordMistakeMap[wordKey] = (gameState.wordMistakeMap[wordKey] || 0) + 1;
            
            dailyStats.mistakes++;
            saveDailyStats();
            
            // è®°å½•å†å²é”™è¯¯å­—æ¯
            if (!gameState.historicalMistakes[wordKey]) {
                gameState.historicalMistakes[wordKey] = [];
            }
            if (!gameState.historicalMistakes[wordKey].includes(wrongOption.letter)) {
                gameState.historicalMistakes[wordKey].push(wrongOption.letter);
            }
            
            // è§†è§‰åé¦ˆï¼šèŠ‚ç‚¹å˜çº¢å¹¶æ·¡å‡º
            wrongOption.state = 'wrong';
            wrongOption.targetScale = 0.8;
            
            // å°†é”™è¯¯èŠ‚ç‚¹ç§»å…¥ fadingNodes æ•°ç»„ï¼Œä»¥ä¾¿é‡æ–°ç”Ÿæˆé€‰é¡¹æ—¶å®ƒè¿˜èƒ½ç»§ç»­æ˜¾ç¤ºæ·¡å‡ºåŠ¨ç”»
            gameState.fadingNodes.push(wrongOption);
            setTimeout(() => wrongOption.state = 'fading', 300);

            // é€»è¾‘åé¦ˆï¼šé‡ç½® Combo
            gameState.combo = 1;
            updateUI();

            // å±å¹•éœ‡åŠ¨æ•ˆæœ (ç®€å•å®ç°ï¼šç»™ body åŠ ä¸ª class)
            document.body.style.transform = 'translate(5px, 5px)';
            setTimeout(() => document.body.style.transform = 'translate(-5px, -5px)', 50);
            setTimeout(() => document.body.style.transform = 'translate(5px, -5px)', 100);
            setTimeout(() => document.body.style.transform = 'translate(0, 0)', 150);
            
            // é”™è¯¯è®¡æ•°é€»è¾‘
            if (now - gameState.lastMistakeTime < 3000) {
                // 3ç§’å†…è¿ç»­é”™è¯¯
                gameState.mistakeCount++;
            } else {
                gameState.mistakeCount = 1;
            }
            gameState.lastMistakeTime = now;
            
            if (gameState.mistakeCount >= 3) {
                // è¿ç»­é”™è¯¯3æ¬¡ï¼Œè§¦å‘å¼ºåˆ¶è®°å¿†
                triggerMemorization();
            } else {
                // é‡æ–°ç”Ÿæˆé€‰é¡¹ï¼Œé˜²æ­¢çŒœæµ‹
                const parentNode = gameState.nodes[gameState.nodes.length - 1];
                generateOptions(parentNode);
            }
        }

        function triggerMemorization() {
            dailyStats.deaths++;
            saveDailyStats();
            
            gameState.isTransitioning = true;
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            
            const overlay = document.getElementById('memorizeOverlay');
            document.getElementById('memoWord').innerText = formatWord(currentWordObj.word);
            document.getElementById('memoMeaning').innerText = currentWordObj.meaning;
            const countdownEl = document.getElementById('memoCountdown');
            
            overlay.classList.remove('hidden');
            
            let timeLeft = 10;
            countdownEl.innerText = timeLeft;
            
            const timer = setInterval(() => {
                timeLeft--;
                countdownEl.innerText = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    overlay.classList.add('hidden');
                    
                    // æ‰æ ¹æŒ‘æˆ˜ï¼šå¦‚æœé”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œå¼ºåˆ¶å€’åºæ‹¼å†™
                    const wordKey = currentWordObj.word;
                    if (gameState.wordMistakeMap[wordKey] > 2) {
                        startGroundingMode();
                    } else {
                        // é‡ç½®å½“å‰å•è¯çš„è¿›åº¦
                        resetCurrentWord();
                    }
                }
            }, 1000);
        }

        function startGroundingMode() {
            // ç®€å•çš„æ‰æ ¹æŒ‘æˆ˜ï¼šé‡ç½®å•è¯ï¼Œä½†æç¤ºç”¨æˆ·éœ€è¦æ›´åŠ å°å¿ƒ
            // å¯ä»¥åœ¨è¿™é‡ŒåŠ å…¥æ›´å¤æ‚çš„é€»è¾‘ï¼Œæ¯”å¦‚å€’åºæ‹¼å†™ï¼Œè¿™é‡Œä¸ºäº†ä¿æŒä»£ç ç®€æ´ï¼Œæˆ‘ä»¬åªåšæç¤ºå¹¶é‡ç½®
            alert("æ‰æ ¹æŒ‘æˆ˜ï¼šè¯·ä»”ç»†æ‹¼å†™ï¼");
            resetCurrentWord();
        }

        function resetCurrentWord() {
            gameState.mistakeCount = 0;
            gameState.currentStepIndex = 0;
            
            gameState.nodes = gameState.nodes.slice(0, gameState.currentWordStartIndex + 1);
            
            const rootNode = gameState.nodes[gameState.nodes.length - 1];
            
            gameState.targetCameraY = height * 0.5 - rootNode.y;
            gameState.targetCameraX = width * 0.5 - rootNode.x;
            
            gameState.isTransitioning = false;
            updateUI();
            advanceAfterStep(rootNode);
        }

        function updateUI() {
            document.getElementById('scoreDisplay').innerText = gameState.score;
            document.getElementById('comboDisplay').innerText = `x${gameState.combo}`;
            document.getElementById('currentMeaningDisplay').innerText = currentDictionary[gameState.currentWordIndex].meaning;
            
            const totalWords = dictionaries[currentDictName] ? dictionaries[currentDictName].length : currentDictionary.length;
            const learnedWords = getLearnedCount(currentDictName);
            document.getElementById('progressDisplay').innerText = `${learnedWords}/${totalWords}`;
            
            const steps = gameState.parsedSteps;
            let html = '';
            let isFirstLetter = true;
            for (let i = 0; i < steps.length; i++) {
                const s = steps[i];
                let d = s.type === 'input' ? s.displayChar : s.display;
                if (s.type === 'input' && isFirstLetter) {
                    d = d.toUpperCase();
                    isFirstLetter = false;
                }
                if (s.type === 'auto' && s.subType === 'space') {
                    isFirstLetter = true;
                }
                const escaped = d.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                if (i <= gameState.currentStepIndex) {
                    html += `<span style="color:#4CAF50;">${escaped}</span>`;
                }
            }
            document.getElementById('selectedLettersDisplay').innerHTML = html;
        }

        // --- å¿«é€Ÿè®°å¿†ç³»ç»Ÿ ---
        function promptQuickMemo() {
            gameState.isPromptingMemo = true;
            document.getElementById('quickMemoPromptOverlay').classList.remove('hidden');
        }

        function showQuickMemo() {
            gameState.isPromptingMemo = false;
            gameState.isShowingMemo = true;
            document.getElementById('quickMemoPromptOverlay').classList.add('hidden');
            
            const listEl = document.getElementById('quickMemoList');
            listEl.innerHTML = '';
            
            // å¦‚æœæ˜¯æ¸¸æˆåˆšå¼€å§‹ï¼ˆnodesä¸ºç©ºï¼‰ï¼Œä»å½“å‰indexå¼€å§‹ï¼Œå¦åˆ™ä»ä¸‹ä¸€ä¸ªå•è¯å¼€å§‹
            const startIdx = gameState.nodes.length === 0 ? gameState.currentWordIndex : gameState.currentWordIndex + 1;
            const endIdx = Math.min(startIdx + gameState.clusterSize, currentDictionary.length);
            
            for (let i = startIdx; i < endIdx; i++) {
                const item = currentDictionary[i];
                const row = document.createElement('div');
                row.style.cssText = 'padding: 6px 0; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; gap: 12px; cursor: pointer;';
                row.innerHTML = `<span style="color: #4CAF50; font-weight: bold; letter-spacing: 1px; white-space: nowrap; flex-shrink: 0;">${formatWord(item.word)}</span><span style="color: #ccc; text-align: right;">${item.meaning}</span>`;
                row.addEventListener('click', () => {
                    speakWordPhrase(item.word);
                });
                listEl.appendChild(row);
            }
            
            document.getElementById('quickMemoDisplayOverlay').classList.remove('hidden');
        }

        function dismissQuickMemo() {
            gameState.isPromptingMemo = false;
            gameState.isShowingMemo = false;
            document.getElementById('quickMemoPromptOverlay').classList.add('hidden');
            document.getElementById('quickMemoDisplayOverlay').classList.add('hidden');
            
            if (gameState.nodes.length === 0) {
                startGameplay();
            } else {
                startNextWord();
            }
        }

        document.getElementById('btnQuickMemoYes').addEventListener('click', () => showQuickMemo());
        document.getElementById('btnQuickMemoNo').addEventListener('click', () => dismissQuickMemo());
        document.getElementById('btnQuickMemoDone').addEventListener('click', () => dismissQuickMemo());

        // --- 6. æ™ºèƒ½å¹²æ‰°é¡¹ä¸æ— ç¼è¡”æ¥ ---
        function generateOptions(parentNode) {
            const nextIdx = gameState.currentStepIndex + 1;
            if (nextIdx >= gameState.parsedSteps.length) return;
            const nextStep = gameState.parsedSteps[nextIdx];
            if (nextStep.type !== 'input') return;
            const correctLetter = nextStep.char;
            
            const distractors = getDistractors(correctLetter);
            
            const options = [correctLetter, ...distractors];
            options.sort(() => Math.random() - 0.5);

            gameState.activeOptions = [];
            
            // æ‰‡å½¢åˆ†å¸ƒå‚æ•°
            const numOptions = options.length;
            const spreadAngle = Math.PI / 3 + (numOptions - 3) * (Math.PI / 8);
            const startAngle = -Math.PI / 2 - spreadAngle / 2;
            const angleStep = numOptions > 1 ? spreadAngle / (numOptions - 1) : 0;
            const distance = numOptions > 3 ? 80 + (numOptions - 3) * 20 : 80;

            const margin = 40;
            const desiredGap = 52;
            const availableWidth = Math.max(60, width - margin * 2);
            const minGap = numOptions > 1
                ? Math.min(desiredGap, availableWidth / (numOptions - 1))
                : desiredGap;

            const positioned = options.map((letter, index) => {
                const angle = startAngle + index * angleStep;
                let x = parentNode.x + Math.cos(angle) * distance;
                x = Math.max(margin, Math.min(width - margin, x));
                const y = parentNode.y + Math.sin(angle) * distance;
                return { letter, x, y };
            });

            positioned.sort((a, b) => a.x - b.x);

            for (let i = 1; i < positioned.length; i++) {
                if (positioned[i].x - positioned[i - 1].x < minGap) {
                    positioned[i].x = positioned[i - 1].x + minGap;
                }
            }

            const rightOverflow = positioned.length > 0 ? positioned[positioned.length - 1].x - (width - margin) : 0;
            if (rightOverflow > 0) {
                positioned.forEach(p => p.x -= rightOverflow);
            }

            const leftOverflow = positioned.length > 0 ? margin - positioned[0].x : 0;
            if (leftOverflow > 0) {
                positioned.forEach(p => p.x += leftOverflow);
            }

            positioned.forEach(item => {
                item.x = Math.max(margin, Math.min(width - margin, item.x));
                const isCorrect = item.letter === correctLetter;
                const node = new Node(item.x, item.y, item.letter, isCorrect, parentNode);
                gameState.activeOptions.push(node);
            });
        }

        function getDistractors(correctLetter) {
            // ç®€å•çš„è¿‘éŸ³/è¿‘å½¢/ç›¸é‚»é”®ç®—æ³•
            const map = {
                'A': ['S', 'Q', 'Z'], 'B': ['V', 'N', 'P'], 'C': ['X', 'V', 'S'],
                'D': ['S', 'F', 'E'], 'E': ['W', 'R', 'D'], 'F': ['D', 'G', 'R'],
                'G': ['F', 'H', 'T'], 'H': ['G', 'J', 'Y'], 'I': ['U', 'O', 'K'],
                'J': ['H', 'K', 'U'], 'K': ['J', 'L', 'I'], 'L': ['K', 'O', 'P'],
                'M': ['N', 'J', 'K'], 'N': ['B', 'M', 'H'], 'O': ['I', 'P', 'L'],
                'P': ['O', 'Q', 'B'], 'Q': ['W', 'A', 'P'], 'R': ['E', 'T', 'F'],
                'S': ['A', 'D', 'W'], 'T': ['R', 'Y', 'G'], 'U': ['Y', 'I', 'J'],
                'V': ['C', 'B', 'F'], 'W': ['Q', 'E', 'S'], 'X': ['Z', 'C', 'S'],
                'Y': ['T', 'U', 'H'], 'Z': ['A', 'X', 'S']
            };
            
            let choices = map[correctLetter] || ['A', 'E', 'I', 'O', 'U'];

            let maxOptions = 3;
            if (gameState.combo >= 100) maxOptions = 6;
            else if (gameState.combo >= 50) maxOptions = 5;
            else if (gameState.combo >= 20) maxOptions = 4;
            const numDistractors = maxOptions - 1;

            choices.sort(() => Math.random() - 0.5);

            if (choices.length < numDistractors) {
                const allLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').filter(c => c !== correctLetter && !choices.includes(c));
                allLetters.sort(() => Math.random() - 0.5);
                choices = choices.concat(allLetters);
            }

            let distractors = choices.slice(0, numDistractors);
            
            // æ™ºèƒ½å›å£°ï¼šå¦‚æœå†å²ä¸Šæœ‰é”™è¯¯è®°å½•ï¼Œä¼˜å…ˆä½¿ç”¨å†å²é”™è¯¯å­—æ¯ä½œä¸ºå¹²æ‰°é¡¹
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            const wordKey = currentWordObj.word;
            if (gameState.historicalMistakes[wordKey] && gameState.historicalMistakes[wordKey].length > 0) {
                // éšæœºå–ä¸€ä¸ªå†å²é”™è¯¯å­—æ¯æ›¿æ¢æ‰ä¸€ä¸ªé»˜è®¤å¹²æ‰°é¡¹
                const histMistake = gameState.historicalMistakes[wordKey][Math.floor(Math.random() * gameState.historicalMistakes[wordKey].length)];
                if (histMistake !== correctLetter && !distractors.includes(histMistake)) {
                    distractors[0] = histMistake;
                }
            }
            
            return distractors;
        }

        function completeWord() {
            gameState.isTransitioning = true;
            gameState.activeOptions = []; // æ¸…ç©ºå½“å‰é€‰é¡¹

            // è®°å½•å†å²é”™è¯¯
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            speakWordPhrase(currentWordObj.word);
            const wordKey = currentWordObj.word;
            if (gameState.wordMistakeMap[wordKey] > 0) {
                // å¦‚æœè¿™ä¸ªå•è¯æœ‰é”™è¯¯ï¼Œè®°å½•ä¸‹æ¥
                if (!gameState.historicalMistakes[wordKey]) {
                    gameState.historicalMistakes[wordKey] = [];
                }
                // ç®€å•èµ·è§ï¼Œè¿™é‡Œåªè®°å½•æœ‰é”™è¯¯å‘ç”Ÿï¼Œå®é™…å¯ä»¥è®°å½•å…·ä½“æŒ‰é”™äº†å“ªä¸ªå­—æ¯
                // è¿™é‡Œæˆ‘ä»¬å‡è®¾åœ¨ handleMistake ä¸­è®°å½•äº†å…·ä½“å­—æ¯ï¼Œä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªè®°å½•å•è¯é”™è¯¯æ¬¡æ•°
            }

            // æ›´æ–°ç°‡è¿›åº¦
            gameState.wordsCompletedInCluster++;
            dailyStats.wordsCompleted++;
            saveDailyStats();
            updateProgressGauge();

            markWordLearned(currentDictName, currentWordObj.word);

            // åœ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—è®°å½•å•è¯æ ‡ç­¾
            const lastNode = gameState.nodes[gameState.nodes.length - 1];
            gameState.wordLabels.push({
                x: lastNode.x,
                y: lastNode.y,
                word: currentWordObj.word,
                meaning: currentWordObj.meaning
            });

            // æ˜¾ç¤ºå®Œæ•´å•è¯å’Œä¸­æ–‡é‡Šä¹‰
            const meaningDisplay = document.getElementById('meaningDisplay');
            meaningDisplay.innerHTML = `
                <div class="word">${formatWord(currentWordObj.word)}</div>
                <div class="meaning">${currentWordObj.meaning}</div>
            `;
            meaningDisplay.classList.add('show-meaning');

            // 1ç§’ååˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå•è¯æˆ–ç»“ç®—ç°‡
            setTimeout(() => {
                meaningDisplay.classList.remove('show-meaning');
                
                if (gameState.wordsCompletedInCluster >= gameState.clusterSize) {
                    settleCluster();
                } else if (gameState.currentWordIndex + 1 >= currentDictionary.length) {
                    // è¯åº“æ‰€æœ‰å•è¯å·²å®Œæˆ
                    settleCluster();
                } else {
                    startNextWord();
                }
            }, 1000);
        }

        function startNextWord() {
            gameState.currentWordIndex = (gameState.currentWordIndex + 1) % currentDictionary.length;
            
            const nextPhrase = currentDictionary[gameState.currentWordIndex].word;
            gameState.parsedSteps = parsePhrase(nextPhrase);
            gameState.currentStepIndex = 0;
            
            const lastNode = gameState.nodes[gameState.nodes.length - 1];
            const firstStep = gameState.parsedSteps[0];
            
            const newRootY = lastNode.y - 150;
            const newRootNode = new Node(width / 2, newRootY, firstStep.char, true);
            newRootNode.state = 'completed';
            newRootNode.scale = 0;
            newRootNode.targetScale = 1;
            
            newRootNode.isNewTreeRoot = true;
            gameState.nodes.push(newRootNode);
            
            gameState.currentWordStartIndex = gameState.nodes.length - 1;
            
            gameState.targetCameraY = height * 0.5 - newRootY;
            gameState.targetCameraX = 0;
            
            gameState.isTransitioning = false;
            updateUI();
            advanceAfterStep(newRootNode);
        }

        function settleCluster() {
            gameState.isSettling = true;
            
            // è§†è§’æ‹‰è¿œ
            gameState.targetCameraZoom = 0.5;
            // è‰²ç›¸åç§» (ä¾‹å¦‚æ¯æ¬¡åç§» 60 åº¦)
            gameState.targetBgHue = (gameState.bgHue + 60) % 360;
            
            // æ˜¾ç¤ºç»“ç®—å¡ç‰‡
            const card = document.getElementById('settlementCard');
            const title = document.getElementById('settlementTitle');
            const stats = document.getElementById('settlementStats');
            
            title.innerText = `Cluster Completed!`;
            stats.innerText = `Words: ${gameState.clusterSize} | Mistakes: ${Object.values(gameState.wordMistakeMap).reduce((a, b) => a + b, 0)}`;
            
            card.classList.remove('hidden');
            
            // 3ç§’åæ¢å¤å¹¶è¿›å…¥ä¸‹ä¸€ä¸ªç°‡
            setTimeout(() => {
                card.classList.add('hidden');
                
                // æ¢å¤è§†è§’
                gameState.targetCameraZoom = 1.0;
                
                // é‡ç½®ç°‡çŠ¶æ€
                gameState.wordsCompletedInCluster = 0;
                gameState.wordMistakeMap = {};
                updateProgressGauge();
                
                gameState.isSettling = false;
                
                // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€ä¸ªå•è¯
                if (gameState.currentWordIndex + 1 < currentDictionary.length) {
                    // å…ˆè¯¢é—®æ˜¯å¦éœ€è¦å¿«é€Ÿè®°å¿†
                    promptQuickMemo();
                } else {
                    // æ‰€æœ‰å•è¯å®Œæˆäº†ï¼Œå¯ä»¥å›åˆ°èœå•
                    alert('æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰å•è¯ï¼');
                    document.getElementById('menuLayer').classList.remove('hidden');
                    document.getElementById('uiLayer').classList.add('hidden');
                }
            }, 3000);
        }

        function skipWord() {
            if (gameState.isTransitioning || gameState.isSettling || gameState.isAutoDrawing) return;
            
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            const wordKey = currentWordObj.word;
            gameState.wordMistakeMap[wordKey] = (gameState.wordMistakeMap[wordKey] || 0) + 5;
            
            let lastNode = gameState.nodes[gameState.nodes.length - 1];
            
            for (let i = gameState.currentStepIndex + 1; i < gameState.parsedSteps.length; i++) {
                const step = gameState.parsedSteps[i];
                const display = step.type === 'input' ? step.char : step.display;
                const newNode = new Node(lastNode.x, lastNode.y - 60, display, true, lastNode);
                newNode.state = 'completed';
                if (step.type === 'auto') newNode.nodeType = step.subType;
                gameState.nodes.push(newNode);
                lastNode = newNode;
            }
            
            gameState.currentStepIndex = gameState.parsedSteps.length - 1;
            completeWord();
        }

        function pruneNode() {
            if (gameState.isTransitioning || gameState.isSettling || gameState.isAutoDrawing) return;
            if (gameState.currentStepIndex <= 0) return;
            
            const minNodeCount = gameState.currentWordStartIndex + 1;
            if (gameState.nodes.length <= minNodeCount) return;
            
            let target = gameState.currentStepIndex - 1;
            while (target > 0 && gameState.parsedSteps[target].type === 'auto') {
                target--;
            }
            
            const nodesToRemove = gameState.currentStepIndex - target;
            for (let i = 0; i < nodesToRemove; i++) {
                if (gameState.nodes.length > minNodeCount) gameState.nodes.pop();
            }
            gameState.currentStepIndex = target;
            
            const parentNode = gameState.nodes[gameState.nodes.length - 1];
            gameState.targetCameraY = height * 0.5 - parentNode.y;
            gameState.targetCameraX = width * 0.5 - parentNode.x;
            
            advanceAfterStep(parentNode);
            updateUI();
        }

        // åˆå§‹åŒ–åŠ è½½è¯åº“
        loadDictionaries();
        loadDailyStats();
    </script>
</body>
</html>