<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX é€å°æ—¶æ°”è±¡é‡‡æ ·</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            min-height: 100vh;
            padding: 24px;
            color: #1a1a1a;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 18px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            padding: 28px 32px;
            background: linear-gradient(135deg, #4facfe 0%, #00c6ff 100%);
            color: #ffffff;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 8px;
        }

        .header p {
            opacity: 0.9;
        }

        .content {
            padding: 28px 32px 36px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 1024px) and (orientation: landscape) {
            .content {
                grid-template-columns: 400px 1fr;
            }
            
            .card-left {
                grid-column: 1;
            }
            
            .card-right {
                grid-column: 2;
                grid-row: 1 / 4;
            }
        }

        .card {
            border: 1px solid #e6e6e6;
            border-radius: 14px;
            padding: 20px;
            background: #ffffff;
        }

        .card h2 {
            font-size: 1.2em;
            margin-bottom: 14px;
            color: #2d2d2d;
        }

        .upload-area {
            border: 2px dashed #4facfe;
            border-radius: 12px;
            padding: 28px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            background: #f5fbff;
            border-color: #00c6ff;
        }

        .upload-area.dragover {
            background: #e9f7ff;
            border-color: #00c6ff;
            transform: scale(1.01);
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 14px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #4a4a4a;
        }

        input[type="datetime-local"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid #d9d9d9;
            font-size: 0.95em;
        }

        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #4facfe 0%, #00c6ff 100%);
            color: #ffffff;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(0, 198, 255, 0.35);
        }

        .status {
            margin-top: 10px;
            color: #1f6f8b;
            font-size: 0.95em;
        }

        .chart-wrapper {
            width: 100%;
            overflow-x: auto;
        }

        #weatherChart {
            width: 100%;
            min-height: 320px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        th, td {
            padding: 10px 8px;
            border-bottom: 1px solid #e6e6e6;
            text-align: left;
        }

        th {
            background: #f5fbff;
        }
 card-left
        .note {
            color: #6b6b6b;
            font-size: 0.85em;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒ¤ï¸ GPX é€å°æ—¶æ°”è±¡é‡‡æ ·</h1>
            <p>è¯»å– GPX è·¯çº¿å¹¶æŒ‰åŒ€é€Ÿé€å°æ—¶é‡‡æ ·ï¼Œè°ƒç”¨ Open-Meteo è·å–å¤©æ°”ã€æ°”æ¸©ã€é£åŠ›ã€é£å‘ã€‚</p>
        </div>
        <div class="content">
            <div class="card">
                <h2>1. ä¸Šä¼  GPX/TCX æ–‡ä»¶</h2>
                <div id="uploadArea" class="upload-area">
                    <div style="font-size: 2em;">ğŸ“¤</div>
                    <p style="margin-top: 8px;">æ‹–æ‹½ GPX/TCX æ–‡ä»¶è‡³æ­¤æˆ–ç‚¹å‡»é€‰æ‹©</p>
                    <p style="margin-top: 6px; color: #6b6b6b; font-size: 0.9em;">æ”¯æŒ .gpx / .tcx</p>
                </div>
                <input id="fileInput" type="file" accept=".gpx,.tcx" style="display: none;">
                <div id="fileInfo" class="status"></div>
            </div>

            <div class="card card-left">
                <h2>2. è®¾ç½®æ—¶é—´èŒƒå›´</h2>
                <div class="form-grid">
                    <div>
                        <label for="startTime">èµ·å§‹æ—¶é—´</label>
                        <input id="startTime" type="datetime-local">
                    </div>
                    <div>
                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                            <label for="endTime" id="endLabel">ç»“æŸæ—¶é—´</label>
                            <label style="font-weight: 500; color: #4a4a4a; display: flex; align-items: center; gap: 6px;">
                                <input type="checkbox" id="useDuration" style="transform: translateY(1px);">
                                å®Œèµ›æ—¶é•¿
                            </label>
                        </div>
                        <input id="endTime" type="datetime-local">
                        <input id="durationHours" type="number" min="0" step="0.1" placeholder="å®Œèµ›æ—¶é•¿ï¼ˆå°æ—¶ï¼‰" style="margin-top: 8px; display: none;">
                    </div>
                </div>
                <div class="note">é‡‡æ ·è§„åˆ™ï¼šåŒ…å« startï¼›æŒ‰æ•´ç‚¹é€å°æ—¶é‡‡æ ·ï¼›è‹¥ end éæ•´ç‚¹åˆ™é¢å¤–åŒ…å« endã€‚</div>
            </div>

            <div class="card card-left">
                <h2>3. ç”Ÿæˆç»“æœ</h2>
                <button id="generateBtn" class="btn" disabled>ç”Ÿæˆé€å°æ—¶æ°”è±¡é‡‡æ ·</button>
                <button id="exportBtn" class="btn" style="margin-top: 10px;" disabled>å¯¼å‡ºè¡¨æ ¼ CSV</button>
                <button id="shareBtn" class="btn" style="margin-top: 10px;" disabled>åˆ†äº«é“¾æ¥</button>
                <div id="status" class="status"></div>
            </div>

            <div class="card card-right">
                <h2>4. ç»˜å›¾ä¸ç»“æœè¡¨</h2>
                <div class="chart-wrapper">
                    <canvas id="weatherChart"></canvas>
                </div>
                <div id="tableWrapper" style="margin-top: 16px; overflow-x: auto;"></div>
                <div class="note">æ¸©åº¦å•ä½ï¼šÂ°Cï¼Œé£é€Ÿå•ä½ï¼šm/sã€‚</div>
            </div>
        </div>
    </div>

    <script>
        const uploadArea = document.getElementById("uploadArea")
        const fileInput = document.getElementById("fileInput")
        const fileInfo = document.getElementById("fileInfo")
        const startTimeInput = document.getElementById("startTime")
        const endTimeInput = document.getElementById("endTime")
        const useDurationInput = document.getElementById("useDuration")
        const durationHoursInput = document.getElementById("durationHours")
        const endLabel = document.getElementById("endLabel")
        const generateBtn = document.getElementById("generateBtn")
        const exportBtn = document.getElementById("exportBtn")
        const shareBtn = document.getElementById("shareBtn")
        const statusEl = document.getElementById("status")
        const tableWrapper = document.getElementById("tableWrapper")
        const weatherChartCanvas = document.getElementById("weatherChart")

        let gpxData = null
        let chartInstance = null
        let lastSamples = []
        let gpxFileName = "gpx"
        let lastRange = { start: null, end: null }
        let isSharedData = false

        const weatherCodeMap = {
            0: "æ™´æœ—",
            1: "å¤§è‡´æ™´æœ—",
            2: "å±€éƒ¨å¤šäº‘",
            3: "é˜´",
            45: "é›¾",
            48: "é›¾å‡‡",
            51: "æ¯›æ¯›é›¨",
            53: "ä¸­ç­‰æ¯›æ¯›é›¨",
            55: "æµ“æ¯›æ¯›é›¨",
            56: "è½»å¾®å†»é›¨",
            57: "å†»é›¨",
            61: "å°é›¨",
            63: "ä¸­é›¨",
            65: "å¤§é›¨",
            66: "è½»å¾®å†»é›¨",
            67: "å†»é›¨",
            71: "å°é›ª",
            73: "ä¸­é›ª",
            75: "å¤§é›ª",
            77: "é›ªç²’",
            80: "é˜µé›¨",
            81: "ä¸­é˜µé›¨",
            82: "å¼ºé˜µé›¨",
            85: "é˜µé›ª",
            86: "å¼ºé˜µé›ª",
            95: "é›·æš´",
            96: "é›·æš´ä¼´å°å†°é›¹",
            99: "é›·æš´ä¼´å¤§å†°é›¹"
        }

        const weatherCache = new Map()

        function toLocalDatetimeValue(date) {
            const offset = date.getTimezoneOffset() * 60000
            return new Date(date.getTime() - offset).toISOString().slice(0, 16)
        }

        function toLocalDateString(date) {
            const offset = date.getTimezoneOffset() * 60000
            return new Date(date.getTime() - offset).toISOString().slice(0, 10)
        }

        function nextFullHour(date = new Date()) {
            const next = new Date(date)
            next.setMinutes(0, 0, 0)
            next.setHours(next.getHours() + 1)
            return next
        }

        function parseGpx(text) {
            const parser = new DOMParser()
            const xml = parser.parseFromString(text, "application/xml")
            let points = Array.from(xml.getElementsByTagName("trkpt"))
            if (points.length === 0) {
                points = Array.from(xml.getElementsByTagName("rtept"))
            }
            if (points.length === 0) {
                return null
            }

            const result = []
            for (const pt of points) {
                const lat = parseFloat(pt.getAttribute("lat"))
                const lon = parseFloat(pt.getAttribute("lon"))
                const timeNode = pt.getElementsByTagName("time")[0]
                const time = timeNode ? new Date(timeNode.textContent) : null
                if (Number.isFinite(lat) && Number.isFinite(lon)) {
                    result.push({ lat, lon, time })
                }
            }

            if (result.length < 2) {
                return null
            }

            const distances = [0]
            let total = 0
            for (let i = 1; i < result.length; i++) {
                total += haversine(result[i - 1], result[i])
                distances.push(total)
            }

            return {
                points: result,
                distances,
                totalDistance: total
            }
        }

        function parseTcx(text) {
            const parser = new DOMParser()
            const xml = parser.parseFromString(text, "application/xml")
            const points = Array.from(xml.getElementsByTagName("Trackpoint"))
            if (points.length === 0) {
                return null
            }
            const result = []
            for (const pt of points) {
                const position = pt.getElementsByTagName("Position")[0]
                if (!position) {
                    continue
                }
                const latNode = position.getElementsByTagName("LatitudeDegrees")[0]
                const lonNode = position.getElementsByTagName("LongitudeDegrees")[0]
                const timeNode = pt.getElementsByTagName("Time")[0]
                const lat = latNode ? parseFloat(latNode.textContent) : NaN
                const lon = lonNode ? parseFloat(lonNode.textContent) : NaN
                const time = timeNode ? new Date(timeNode.textContent) : null
                if (Number.isFinite(lat) && Number.isFinite(lon)) {
                    result.push({ lat, lon, time })
                }
            }
            if (result.length < 2) {
                return null
            }
            const distances = [0]
            let total = 0
            for (let i = 1; i < result.length; i++) {
                total += haversine(result[i - 1], result[i])
                distances.push(total)
            }
            return {
                points: result,
                distances,
                totalDistance: total
            }
        }

        function haversine(a, b) {
            const R = 6371000
            const toRad = v => v * Math.PI / 180
            const dLat = toRad(b.lat - a.lat)
            const dLon = toRad(b.lon - a.lon)
            const lat1 = toRad(a.lat)
            const lat2 = toRad(b.lat)
            const sin1 = Math.sin(dLat / 2)
            const sin2 = Math.sin(dLon / 2)
            const h = sin1 * sin1 + Math.cos(lat1) * Math.cos(lat2) * sin2 * sin2
            const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h))
            return R * c
        }

        function generateSampleTimes(start, end) {
            const times = [new Date(start)]
            const startCopy = new Date(start)
            const nextHour = new Date(startCopy)
            nextHour.setMinutes(0, 0, 0)
            if (startCopy.getMinutes() !== 0 || startCopy.getSeconds() !== 0 || startCopy.getMilliseconds() !== 0) {
                nextHour.setHours(nextHour.getHours() + 1)
            } else {
                nextHour.setHours(nextHour.getHours() + 1)
            }

            let cursor = nextHour
            while (cursor.getTime() <= end.getTime()) {
                times.push(new Date(cursor))
                cursor = new Date(cursor.getTime() + 3600000)
            }

            const last = times[times.length - 1]
            if (last.getTime() !== end.getTime()) {
                times.push(new Date(end))
            }
            return times
        }

        function interpolateByDistance(gpx, targetDistance, startIndex) {
            const distances = gpx.distances
            const points = gpx.points
            let i = startIndex
            while (i < distances.length - 2 && distances[i + 1] < targetDistance) {
                i += 1
            }
            const d1 = distances[i]
            const d2 = distances[i + 1]
            const ratio = d2 === d1 ? 0 : (targetDistance - d1) / (d2 - d1)
            const p1 = points[i]
            const p2 = points[i + 1]
            const lat = p1.lat + (p2.lat - p1.lat) * ratio
            const lon = p1.lon + (p2.lon - p1.lon) * ratio
            return { lat, lon, index: i }
        }

        function roundCoord(value, decimals = 3) {
            const factor = Math.pow(10, decimals)
            return Math.round(value * factor) / factor
        }

        async function fetchWeather(lat, lon, startDate, endDate) {
            const key = `${lat.toFixed(3)},${lon.toFixed(3)}`
            if (weatherCache.has(key)) {
                return weatherCache.get(key)
            }
            const url = new URL("https://api.open-meteo.com/v1/forecast")
            url.searchParams.set("latitude", lat)
            url.searchParams.set("longitude", lon)
            url.searchParams.set("hourly", "weathercode,temperature_2m,apparent_temperature,windspeed_10m,winddirection_10m")
            url.searchParams.set("wind_speed_unit", "ms")
            url.searchParams.set("timezone", "auto")
            url.searchParams.set("start_date", startDate)
            url.searchParams.set("end_date", endDate)
            const response = await fetch(url.toString())
            if (!response.ok) {
                if (response.status === 429) {
                    throw new Error(`API è¯·æ±‚é™åˆ¶ï¼šè¯·ç¨åå†è¯• (HTTP ${response.status})`)
                } else if (response.status === 400) {
                    throw new Error(`åæ ‡æ— æ•ˆæˆ–å‚æ•°é”™è¯¯ (HTTP ${response.status})`)
                } else if (response.status >= 500) {
                    throw new Error(`å¤©æ°”æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ (HTTP ${response.status})`)
                } else {
                    throw new Error(`æ— æ³•è·å–å¤©æ°”æ•°æ® (HTTP ${response.status})`)
                }
            }
            const data = await response.json()
            weatherCache.set(key, data)
            return data
        }

        function closestHourIndex(times, target) {
            let closestIndex = 0
            let closestDiff = Infinity
            for (let i = 0; i < times.length; i++) {
                const diff = Math.abs(new Date(times[i]).getTime() - target.getTime())
                if (diff < closestDiff) {
                    closestDiff = diff
                    closestIndex = i
                }
            }
            return closestIndex
        }

        function windDirectionText(deg) {
            if (!Number.isFinite(deg)) {
                return "-"
            }
            const directions = [
                "åŒ—é£",
                "åŒ—åä¸œ",
                "ä¸œåŒ—é£",
                "ä¸œååŒ—",
                "ä¸œé£",
                "ä¸œåå—",
                "ä¸œå—é£",
                "å—åä¸œ",
                "å—é£",
                "å—åè¥¿",
                "è¥¿å—é£",
                "è¥¿åå—",
                "è¥¿é£",
                "è¥¿ååŒ—",
                "è¥¿åŒ—é£",
                "åŒ—åè¥¿"
            ]
            const index = Math.round(((deg % 360) + 360) % 360 / 22.5) % 16
            return directions[index]
        }

        function renderChart(samples) {
            const labels = samples.map(item => item.timeLabel)
            const temperature = samples.map(item => item.temperature)
            const apparentTemperature = samples.map(item => item.apparentTemperature)
            const weatherText = samples.map(item => item.weather)

            if (chartInstance) {
                chartInstance.destroy()
            }

            chartInstance = new Chart(weatherChartCanvas.getContext("2d"), {
                type: "line",
                data: {
                    labels,
                    datasets: [
                        {
                            label: "æ°”æ¸© (Â°C)",
                            data: temperature,
                            borderColor: "#ffb347",
                            backgroundColor: "rgba(255, 179, 71, 0.2)",
                            tension: 0.3,
                            yAxisID: "yTemp"
                        },
                        {
                            label: "ä½“æ„Ÿæ¸©åº¦ (Â°C)",
                            data: apparentTemperature,
                            borderColor: "#4facfe",
                            backgroundColor: "rgba(79, 172, 254, 0.2)",
                            tension: 0.3,
                            yAxisID: "yTemp"
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: "index",
                        intersect: false
                    },
                    scales: {
                        yTemp: {
                            position: "left",
                            title: {
                                display: true,
                                text: "æ¸©åº¦ (Â°C)"
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterBody: context => {
                                    const index = context[0].dataIndex
                                    return `å¤©æ°”: ${weatherText[index]}`
                                }
                            }
                        }
                    }
                }
            })
        }

        function renderTable(samples) {
            if (samples.length === 0) {
                tableWrapper.innerHTML = ""
                return
            }
            const rows = samples.map(item => {
                return `
                    <tr>
                        <td>${item.timeLabel}</td>
                        <td>${item.weather}</td>
                        <td>${item.temperature.toFixed(1)}</td>
                        <td>${item.apparentTemperature.toFixed(1)}</td>
                        <td>${item.windSpeed.toFixed(1)}</td>
                        <td>${windDirectionText(item.windDirection)}</td>
                        <td>${item.distanceKm.toFixed(2)}</td>
                    </tr>
                `
            }).join("")

            tableWrapper.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>æ—¶é—´</th>
                            <th>å¤©æ°”æƒ…å†µ</th>
                            <th>æ°”æ¸© (Â°C)</th>
                            <th>ä½“æ„Ÿæ¸©åº¦ (Â°C)</th>
                            <th>é£é€Ÿ (m/s)</th>
                            <th>é£å‘</th>
                            <th>æ²¿çº¿é‡Œç¨‹ (km)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            `
        }

        function formatTimeLabel(date) {
            return new Intl.DateTimeFormat("zh-CN", {
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                hour12: false
            }).format(date)
        }

        function exportCsv(samples) {
            if (!samples.length) {
                return
            }
            const header = ["æ—¶é—´", "å¤©æ°”æƒ…å†µ", "æ°”æ¸©(Â°C)", "ä½“æ„Ÿæ¸©åº¦(Â°C)", "é£é€Ÿ(m/s)", "é£å‘", "æ²¿çº¿é‡Œç¨‹(km)"]
            const rows = samples.map(item => [
                item.timeLabel,
                item.weather,
                item.temperature.toFixed(1),
                item.apparentTemperature.toFixed(1),
                item.windSpeed.toFixed(1),
                windDirectionText(item.windDirection),
                item.distanceKm.toFixed(2)
            ])
            const csv = [header, ...rows].map(row => row.map(cell => `"${String(cell).replace(/"/g, "\"\"")}"`).join(",")).join("\n")
            const blob = new Blob(["\uFEFF", csv], { type: "text/csv;charset=utf-8;" })
            const url = URL.createObjectURL(blob)
            const link = document.createElement("a")
            const safeStart = lastRange.start ? formatFileTime(lastRange.start) : ""
            const safeEnd = lastRange.end ? formatFileTime(lastRange.end) : ""
            const base = gpxFileName || "gpx"
            const nameParts = [base, safeStart, safeEnd].filter(Boolean)
            const filename = nameParts.join("_") || `gpx-hourly-weather-${new Date().toISOString().replace(/[:]/g, "-").slice(0, 19)}`
            link.href = url
            link.download = `${filename}.csv`
            document.body.appendChild(link)
            link.click()
            document.body.removeChild(link)
            URL.revokeObjectURL(url)
        }

        function formatFileTime(date) {
            const pad = value => String(value).padStart(2, "0")
            return `${date.getFullYear()}${pad(date.getMonth() + 1)}${pad(date.getDate())}-${pad(date.getHours())}${pad(date.getMinutes())}`
        }

        function compressData(data) {
            const json = JSON.stringify(data)
            const bytes = new TextEncoder().encode(json)
            const compressed = pako.deflate(bytes, { level: 9 })
            let binary = ""
            for (let i = 0; i < compressed.length; i++) {
                binary += String.fromCharCode(compressed[i])
            }
            return btoa(binary)
        }

        function decompressData(encoded) {
            try {
                const binary = atob(encoded)
                const bytes = new Uint8Array(binary.length)
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i)
                }
                const decompressed = pako.inflate(bytes)
                const json = new TextDecoder().decode(decompressed)
                return JSON.parse(json)
            } catch {
                return null
            }
        }

        function setStatus(text) {
            statusEl.textContent = text
        }

        function setFileInfo(text) {
            fileInfo.textContent = text
        }

        uploadArea.addEventListener("click", () => fileInput.click())

        uploadArea.addEventListener("dragover", event => {
            event.preventDefault()
            uploadArea.classList.add("dragover")
        })

        uploadArea.addEventListener("dragleave", () => {
            uploadArea.classList.remove("dragover")
        })

        uploadArea.addEventListener("drop", event => {
            event.preventDefault()
            uploadArea.classList.remove("dragover")
            if (event.dataTransfer.files.length > 0) {
                fileInput.files = event.dataTransfer.files
                handleFile(fileInput.files[0])
            }
        })

        fileInput.addEventListener("change", () => {
            if (fileInput.files.length > 0) {
                handleFile(fileInput.files[0])
            }
        })

        useDurationInput.addEventListener("change", () => {
            const useDuration = useDurationInput.checked
            endTimeInput.style.display = useDuration ? "none" : "block"
            durationHoursInput.style.display = useDuration ? "block" : "none"
            endLabel.textContent = useDuration ? "æŒç»­æ—¶é•¿" : "ç»“æŸæ—¶é—´"
        })

        exportBtn.addEventListener("click", () => exportCsv(lastSamples))

        shareBtn.addEventListener("click", () => {
            if (!lastSamples.length) {
                return
            }
            const compressed = compressData({
                samples: lastSamples.map(s => ({
                    t: s.time.getTime(),
                    lat: s.lat,
                    lon: s.lon,
                    d: s.distanceKm,
                    w: s.weather,
                    temp: s.temperature,
                    atemp: s.apparentTemperature,
                    ws: s.windSpeed,
                    wd: s.windDirection
                })),
                fileName: gpxFileName,
                start: lastRange.start ? lastRange.start.getTime() : null,
                end: lastRange.end ? lastRange.end.getTime() : null
            })
            const url = new URL(window.location.href)
            url.search = ""
            url.hash = compressed
            const urlString = url.toString()
            
            if (urlString.length > 100000) {
                const warning = `âš ï¸ é“¾æ¥é•¿åº¦ ${urlString.length} å­—ç¬¦ï¼Œè¶…è¿‡å»ºè®®ä¸Šé™ï¼ˆ100000 å­—ç¬¦ï¼‰ï¼Œå¯èƒ½åœ¨éƒ¨åˆ†æµè§ˆå™¨ä¸­æ— æ³•ä½¿ç”¨`
                setStatus(warning)
                if (!confirm(`${warning}\n\næ˜¯å¦ç»§ç»­å¤åˆ¶ï¼Ÿ`)) {
                    return
                }
            }
            
            navigator.clipboard.writeText(urlString).then(() => {
                setStatus("åˆ†äº«é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿")
            }).catch(() => {
                prompt("åˆ†äº«é“¾æ¥ï¼š", urlString)
            })
        })

        startTimeInput.value = toLocalDatetimeValue(nextFullHour())

        function loadSharedData() {
            const encoded = window.location.hash.slice(1)
            if (!encoded) {
                return
            }
            const data = decompressData(encoded)
            if (!data || !data.samples || !Array.isArray(data.samples)) {
                setStatus("æ— æ³•åŠ è½½åˆ†äº«æ•°æ®")
                return
            }
            lastSamples = data.samples.map(s => ({
                time: new Date(s.t),
                timeLabel: formatTimeLabel(new Date(s.t)),
                lat: s.lat,
                lon: s.lon,
                distanceKm: s.d,
                weather: s.w,
                temperature: s.temp,
                apparentTemperature: s.atemp || s.temp,
                windSpeed: s.ws,
                windDirection: s.wd
            }))
            gpxFileName = data.fileName || "shared"
            if (data.start) {
                lastRange.start = new Date(data.start)
            }
            if (data.end) {
                lastRange.end = new Date(data.end)
            }
            renderChart(lastSamples)
            renderTable(lastSamples)
            exportBtn.disabled = false
            shareBtn.disabled = false
            generateBtn.disabled = false
            generateBtn.textContent = "åˆ·æ–°å¤©æ°”æ•°æ®"
            isSharedData = true
            setFileInfo(`å·²åŠ è½½åˆ†äº«æ•°æ®ï¼Œå…± ${lastSamples.length} ä¸ªé‡‡æ ·ç‚¹`)
            setStatus(`å·²åŠ è½½åˆ†äº«æ•°æ®ï¼Œå…± ${lastSamples.length} ä¸ªé‡‡æ ·ç‚¹`)
        }

        loadSharedData()

        function handleFile(file) {
            if (!file) return
            const lowerName = file.name.toLowerCase()
            const isGpx = lowerName.endsWith(".gpx")
            const isTcx = lowerName.endsWith(".tcx")
            if (!isGpx && !isTcx) {
                setFileInfo("è¯·é€‰æ‹© GPX æˆ– TCX æ–‡ä»¶")
                return
            }
            gpxFileName = file.name.replace(/\.[^/.]+$/, "")
            const reader = new FileReader()
            reader.onload = () => {
                const parsed = isTcx ? parseTcx(reader.result) : parseGpx(reader.result)
                if (!parsed) {
                    setFileInfo("æ— æ³•è§£ææ–‡ä»¶ï¼Œè¯·ç¡®è®¤åŒ…å«è½¨è¿¹ç‚¹")
                    gpxData = null
                    generateBtn.disabled = true
                    return
                }
                gpxData = parsed
                setFileInfo(`å·²åŠ è½½ï¼š${file.name}ï¼Œè½¨è¿¹ç‚¹ ${parsed.points.length} ä¸ªï¼Œæ€»é‡Œç¨‹ ${(parsed.totalDistance / 1000).toFixed(2)} km`)
                const times = parsed.points.map(p => p.time).filter(Boolean)
                if (times.length > 0) {
                    const sorted = times.sort((a, b) => a - b)
                    startTimeInput.value = toLocalDatetimeValue(sorted[0])
                    endTimeInput.value = toLocalDatetimeValue(sorted[sorted.length - 1])
                }
                isSharedData = false
                generateBtn.textContent = "ç”Ÿæˆé€å°æ—¶æ°”è±¡é‡‡æ ·"
                generateBtn.disabled = false
            }
            reader.readAsText(file)
        }

        generateBtn.addEventListener("click", async () => {
            if (isSharedData) {
                if (!lastSamples.length) {
                    setStatus("æ— å¯åˆ·æ–°çš„æ•°æ®")
                    return
                }
                generateBtn.disabled = true
                setStatus("æ­£åœ¨åˆ·æ–°å¤©æ°”æ•°æ®...")
                
                const startDate = toLocalDateString(lastRange.start)
                const endDate = toLocalDateString(lastRange.end)
                
                try {
                    const grouped = new Map()
                    for (const sample of lastSamples) {
                        const roundedLat = roundCoord(sample.lat)
                        const roundedLon = roundCoord(sample.lon)
                        const key = `${roundedLat.toFixed(3)},${roundedLon.toFixed(3)}`
                        sample.cacheKey = key
                        if (!grouped.has(key)) {
                            grouped.set(key, { lat: roundedLat, lon: roundedLon })
                        }
                    }
                    
                    weatherCache.clear()
                    const weatherDataByKey = new Map()
                    for (const [key, info] of grouped.entries()) {
                        const data = await fetchWeather(info.lat, info.lon, startDate, endDate)
                        weatherDataByKey.set(key, data)
                    }
                    
                    for (const sample of lastSamples) {
                        const data = weatherDataByKey.get(sample.cacheKey)
                        const times = data.hourly.time
                        const idx = closestHourIndex(times, sample.time)
                        const code = data.hourly.weathercode[idx]
                        sample.weather = weatherCodeMap[code] || `å¤©æ°”ä»£ç  ${code}`
                        sample.temperature = data.hourly.temperature_2m[idx]
                        sample.apparentTemperature = data.hourly.apparent_temperature[idx]
                        sample.windSpeed = data.hourly.windspeed_10m[idx]
                        sample.windDirection = data.hourly.winddirection_10m[idx]
                    }
                    
                    renderChart(lastSamples)
                    renderTable(lastSamples)
                    setStatus(`åˆ·æ–°å®Œæˆï¼Œå…± ${lastSamples.length} ä¸ªé‡‡æ ·ç‚¹`)
                } catch (error) {
                    console.error("å¤©æ°”æ•°æ®åˆ·æ–°å¤±è´¥ï¼š", error)
                    const errorMsg = error.message || "åˆ·æ–°å¤©æ°”æ•°æ®å¤±è´¥"
                    const detailedMsg = error.stack ? `${errorMsg}ï¼ˆè¯¦è§æ§åˆ¶å°ï¼‰` : errorMsg
                    setStatus(`âŒ ${detailedMsg}`)
                } finally {
                    generateBtn.disabled = false
                }
                return
            }
            
            if (!gpxData) {
                setStatus("è¯·å…ˆä¸Šä¼  GPX æ–‡ä»¶")
                return
            }
            const startValue = startTimeInput.value
            const endValue = endTimeInput.value
            const useDuration = useDurationInput.checked
            if (!startValue || (!endValue && !useDuration)) {
                setStatus("è¯·å¡«å†™èµ·å§‹æ—¶é—´")
                return
            }
            const start = new Date(startValue)
            const end = useDuration
                ? new Date(start.getTime() + Number(durationHoursInput.value || 0) * 3600000)
                : new Date(endValue)
            if (useDuration && (!durationHoursInput.value || Number(durationHoursInput.value) <= 0)) {
                setStatus("è¯·å¡«å†™æœ‰æ•ˆçš„æŒç»­æ—¶é•¿")
                return
            }
            if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime()) || end <= start) {
                setStatus("æ—¶é—´èŒƒå›´æ— æ•ˆ")
                return
            }

            generateBtn.disabled = true
            setStatus("æ­£åœ¨ç”Ÿæˆé‡‡æ ·ç‚¹å¹¶è·å–å¤©æ°”æ•°æ®...")

            const duration = end.getTime() - start.getTime()
            lastRange = { start, end }
            const sampleTimes = generateSampleTimes(start, end)
            const samples = []

            let index = 0
            for (const time of sampleTimes) {
                const ratio = (time.getTime() - start.getTime()) / duration
                const targetDistance = gpxData.totalDistance * Math.min(Math.max(ratio, 0), 1)
                const { lat, lon, index: newIndex } = interpolateByDistance(gpxData, targetDistance, index)
                index = newIndex
                samples.push({
                    time,
                    timeLabel: formatTimeLabel(time),
                    lat,
                    lon,
                    distanceKm: targetDistance / 1000
                })
            }

            const startDate = toLocalDateString(start)
            const endDate = toLocalDateString(end)

            try {
                const grouped = new Map()
                for (const sample of samples) {
                    const roundedLat = roundCoord(sample.lat)
                    const roundedLon = roundCoord(sample.lon)
                    const key = `${roundedLat.toFixed(3)},${roundedLon.toFixed(3)}`
                    sample.cacheKey = key
                    if (!grouped.has(key)) {
                        grouped.set(key, { lat: roundedLat, lon: roundedLon })
                    }
                }

                const weatherDataByKey = new Map()
                for (const [key, info] of grouped.entries()) {
                    const data = await fetchWeather(info.lat, info.lon, startDate, endDate)
                    weatherDataByKey.set(key, data)
                }

                for (const sample of samples) {
                    const data = weatherDataByKey.get(sample.cacheKey)
                    const times = data.hourly.time
                    const idx = closestHourIndex(times, sample.time)
                    const code = data.hourly.weathercode[idx]
                    sample.weather = weatherCodeMap[code] || `å¤©æ°”ä»£ç  ${code}`
                    sample.temperature = data.hourly.temperature_2m[idx]
                    sample.apparentTemperature = data.hourly.apparent_temperature[idx]
                    sample.windSpeed = data.hourly.windspeed_10m[idx]
                    sample.windDirection = data.hourly.winddirection_10m[idx]
                }
                lastSamples = samples
                renderChart(samples)
                renderTable(samples)
                setStatus(`å®Œæˆï¼Œå…± ${samples.length} ä¸ªé‡‡æ ·ç‚¹`)
                exportBtn.disabled = false
                shareBtn.disabled = false
            } catch (error) {
                console.error("å¤©æ°”æ•°æ®è·å–å¤±è´¥ï¼š", error)
                const errorMsg = error.message || "è·å–å¤©æ°”æ•°æ®å¤±è´¥"
                const detailedMsg = error.stack ? `${errorMsg}ï¼ˆè¯¦è§æ§åˆ¶å°ï¼‰` : errorMsg
                setStatus(`âŒ ${detailedMsg}`)
                exportBtn.disabled = true
                shareBtn.disabled = true
            } finally {
                generateBtn.disabled = false
            }
        })
    </script>
</body>
</html>
