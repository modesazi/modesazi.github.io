<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Vine (å•è¯é•¿é’)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #121212; /* æ·±è‰²æç®€èƒŒæ™¯ */
            font-family: 'Courier New', Courier, monospace; /* æç®€ç­‰å®½å­—ä½“ */
            touch-action: none; /* ç¦ç”¨é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼Œå¦‚åŒå‡»ç¼©æ”¾ */
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 14px;
            box-sizing: border-box;
            color: rgba(255, 255, 255, 0.8);
        }
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            gap: 8px;
        }
        #meaningDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #meaningDisplay .word {
            font-size: 64px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 5px;
        }
        #meaningDisplay .meaning {
            font-size: 36px;
            font-weight: normal;
        }
        .show-meaning {
            opacity: 1 !important;
        }
        
        /* åŠ¨æ€è¿›åº¦æ¡ (The Growth Gauge) */
        #progressGauge {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 5;
        }
        .gauge-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            transition: all 0.3s ease;
        }
        .gauge-dot.completed {
            background: #4CAF50;
            border-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }
        .gauge-dot.current {
            border-color: #fff;
            animation: breathe 1.5s infinite alternate;
        }
        @keyframes breathe {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255,255,255,0.5); }
            100% { transform: scale(1.5); box-shadow: 0 0 15px rgba(255,255,255,1); }
        }

        /* ç»“ç®—å¡ç‰‡ */
        #settlementCard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #4CAF50;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            color: white;
            z-index: 15;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.3);
        }
        #settlementCard.hidden {
            display: none;
        }
        
        /* èœå•æ ·å¼ */
        #menuLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(18, 18, 18, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: white;
            z-index: 10;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            box-sizing: border-box;
            padding: 12px 0;
        }
        .menu-box {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #4CAF50;
            width: 80%;
            max-width: 500px;
            text-align: center;
            max-height: calc(100dvh - 24px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            margin: auto 0;
        }
        .menu-view {
            width: 100%;
        }
        #menuSettingsView {
            text-align: left;
        }
        textarea {
            width: 100%;
            height: 150px;
            background: #111;
            color: #4CAF50;
            border: 1px solid #333;
            padding: 10px;
            font-family: monospace;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 5px;
            font-family: inherit;
        }
        button:hover {
            background: #45a049;
        }
        select {
            padding: 10px;
            font-size: 16px;
            background: #111;
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 5px;
            margin-bottom: 20px;
            width: 100%;
        }
        .hidden {
            display: none !important;
        }
        
        /* å¼ºåˆ¶è®°å¿†å±‚æ ·å¼ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
        }
        .overlay-content {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #4CAF50;
            text-align: center;
            max-width: 80%;
        }
        .overlay-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-family: 'Courier New', Courier, monospace;
        }
        .overlay-btn.secondary {
            background: #555;
        }
        .overlay-btn:hover {
            opacity: 0.9;
        }
        #memorizeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
        }

        .overlay-content {
            width: min(92vw, 640px);
            max-width: 92vw;
        }
        .overlay-content h2 {
            font-size: clamp(20px, 5.2vw, 30px);
            line-height: 1.3;
            word-break: break-word;
        }
        .overlay-content p {
            font-size: clamp(14px, 3.8vw, 18px);
            line-height: 1.6;
        }
        #quickMemoList {
            font-size: clamp(14px, 3.8vw, 20px) !important;
            line-height: 1.7 !important;
        }
        #dailyStatsOverlay .overlay-content > div {
            font-size: clamp(14px, 3.8vw, 18px) !important;
            line-height: 2 !important;
        }
        #settlementTitle {
            font-size: clamp(20px, 5vw, 32px);
            line-height: 1.3;
        }
        #settlementStats {
            font-size: clamp(18px, 4.8vw, 24px) !important;
        }
        #settlementCard p {
            font-size: clamp(12px, 3.6vw, 16px) !important;
        }
        #memorizeOverlay h2 {
            font-size: clamp(24px, 8vw, 40px) !important;
            line-height: 1.25;
            text-align: center;
            max-width: 92vw;
            padding: 0 12px;
            box-sizing: border-box;
        }
        #memoWord {
            font-size: clamp(36px, 13vw, 64px) !important;
            letter-spacing: clamp(1px, 0.9vw, 5px) !important;
            max-width: 94vw;
            text-align: center;
            overflow-wrap: anywhere;
            word-break: break-word;
            box-sizing: border-box;
            padding: 0 8px;
        }
        #memoMeaning {
            font-size: clamp(22px, 7vw, 36px) !important;
            line-height: 1.35;
            max-width: 94vw;
            text-align: center;
            overflow-wrap: anywhere;
            word-break: break-word;
            box-sizing: border-box;
            padding: 0 10px;
        }
        #memoCountdown {
            font-size: clamp(36px, 12vw, 64px) !important;
        }

        @media (orientation: portrait) {
            .overlay-content {
                padding: 20px 16px;
                max-width: 90%;
            }
            .overlay-content h2 {
                font-size: 18px;
            }
            .overlay-content p {
                font-size: 14px;
            }
            .overlay-btn {
                font-size: 14px;
                padding: 8px 16px;
            }
            #quickMemoList {
                font-size: 14px !important;
                line-height: 1.6 !important;
            }
            #memorizeOverlay h2 {
                font-size: 22px;
            }
            #memorizeOverlay #memoWord {
                font-size: 36px;
            }
            #memorizeOverlay #memoMeaning {
                font-size: 22px;
            }
            #memorizeOverlay #memoCountdown {
                font-size: 40px;
            }
            #settlementCard {
                padding: 24px;
            }
            #settlementCard h2 {
                font-size: 20px;
            }
            #settlementCard p {
                font-size: 16px;
            }
        }

        @media (orientation: portrait) and (max-width: 414px) {
            #quickMemoList {
                font-size: 12px !important;
                line-height: 1.5 !important;
            }
            .overlay-content {
                padding: 14px 12px;
            }
            #memorizeOverlay #memoWord {
                font-size: 28px;
            }
            #memorizeOverlay #memoMeaning {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- èœå•å±‚ -->
    <div id="menuLayer">
        <div class="menu-box">
            <h1 style="color: #4CAF50; margin-top: 0;">Word Vine</h1>

            <div id="menuMainView" class="menu-view">
                <h3>é€‰æ‹©è¯åº“</h3>
                <div style="display: flex; gap: 10px; width: 100%; margin-bottom: 20px;">
                    <select id="dictSelect" style="margin-bottom: 0; flex-grow: 1;"></select>
                </div>
                <button id="startBtn" style="width: 100%;">å¼€å§‹æ¸¸æˆ</button>
                <button id="openSettingsBtn" style="width: 100%; background: #333; border: 1px solid #555;">è®¾ç½®</button>
            </div>

            <div id="menuSettingsView" class="menu-view hidden">
                <h3 style="margin-bottom: 14px;">è®¾ç½®</h3>
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 16px;">
                    <span style="font-size: 14px; color: #ccc;">æ¯ç»„å•è¯æ•°é‡</span>
                    <input id="clusterSizeInput" type="number" min="3" max="30" step="1" value="7" style="width: 96px; padding: 8px 10px; box-sizing: border-box; background: #111; color: #4CAF50; border: 1px solid #333; border-radius: 5px; text-align: center; font-family: inherit; font-size: 16px;">
                </div>

                <div style="margin-bottom: 12px;">
                    <div style="font-size: 14px; color: #ccc; margin-bottom: 8px;">è¯åº“ç®¡ç†</div>
                    <div id="dictManageList" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>

                <hr style="border-color: #333; margin: 16px 0;">

                <h3 style="margin: 0 0 10px 0;">å¯¼å…¥æ–°è¯åº“ (JSON)</h3>
                <p style="font-size: 12px; color: #aaa; text-align: left;">æ ¼å¼: {"apple": "è‹¹æœ", "tree": "æ ‘"}</p>
                <input type="text" id="dictNameInput" placeholder="è¯åº“åç§° (å¦‚: CET4)" style="width: 100%; padding: 10px; margin-bottom: 10px; box-sizing: border-box; background: #111; color: white; border: 1px solid #333;">
                <textarea id="importData" placeholder='{"word": "meaning"}'></textarea>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                    <button id="loadFileBtn" style="background: #333; border: 1px solid #555;">ä»æ–‡ä»¶åŠ è½½</button>
                    <button id="importBtn">ä¿å­˜å¹¶å¯¼å…¥</button>
                </div>
                <div id="importMsg" style="color: #f44336; font-size: 14px; margin-top: 10px;"></div>

                <hr style="border-color: #333; margin: 16px 0;">

                <h3 style="margin: 0 0 10px 0;">è¿›åº¦è¿ç§»</h3>
                <p style="font-size: 12px; color: #aaa; text-align: left; margin: 0 0 8px 0;">å¯¼å‡ºä¸º JSONï¼Œå¯åœ¨å¦ä¸€å°è®¾å¤‡ï¼ˆå³ä½¿æ²¡æœ‰è¯åº“ï¼‰å®Œæ•´å¯¼å…¥ã€‚</p>
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 8px;">
                    <input type="file" id="progressFileInput" accept=".json" style="display: none;">
                    <button id="exportProgressBtn" style="background: #2e7d32; border: 1px solid #3d8f42; flex: 1;">å¯¼å‡ºè¿›åº¦</button>
                    <button id="importProgressBtn" style="background: #1565c0; border: 1px solid #2a76ca; flex: 1;">å¯¼å…¥è¿›åº¦</button>
                </div>
                <div id="progressTransferMsg" style="color: #f44336; font-size: 14px; margin-top: 10px;"></div>
                <button id="closeSettingsBtn" style="width: 100%; background: #555; margin-top: 16px;">è¿”å›</button>
            </div>
        </div>
    </div>

    <div id="uiLayer" class="hidden">
        <div class="top-bar">
            <div style="display: flex; flex-direction: column; align-items: flex-start; min-width: 50px;">
                <div id="scoreDisplay" style="font-size: 16px;">0</div>
                <div id="comboDisplay" style="font-size: 12px; color: #aaa; margin-top: 2px;">x1</div>
            </div>
            <div style="flex-grow: 1; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                <div id="selectedLettersDisplay" style="font-size: 14px; color: #fff; letter-spacing: 2px; font-weight: bold; text-shadow: 0 0 10px rgba(76,175,80,0.6); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60vw;"></div>
                <div id="currentMeaningDisplay" style="font-size: 13px; color: #4CAF50;"></div>
            </div>
            <div id="progressDisplay" style="font-size: 12px; color: #aaa; min-width: 50px; text-align: right;">0/0</div>
        </div>
        <div id="meaningDisplay"></div>
        <div id="progressGauge"></div>
        <button id="exitBtn" style="position: absolute; bottom: 20px; left: 20px; pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #aaa; padding: 8px 14px; font-size: 14px; border-radius: 20px; cursor: pointer; font-family: inherit;" onclick="confirmExit()">â†© é€€å‡º</button>
        <button id="statsBtn" style="position: absolute; bottom: 20px; right: 20px; pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #aaa; padding: 8px 14px; font-size: 14px; border-radius: 20px; cursor: pointer; font-family: inherit;" onclick="showDailyStats()">ğŸ“Š ä»Šæ—¥ç»Ÿè®¡</button>
    </div>

    <!-- æ¯æ—¥ç»Ÿè®¡æµ®å±‚ -->
    <div id="dailyStatsOverlay" class="overlay hidden">
        <div class="overlay-content" style="min-width: 260px; width: 75%; max-width: 400px;">
            <h2 style="color: #4CAF50; margin-top: 0; margin-bottom: 20px;">ğŸ“Š ä»Šæ—¥ç»Ÿè®¡</h2>
            <div style="text-align: left; font-size: 18px; line-height: 2.2;">
                <div style="display: flex; justify-content: space-between;"><span>å®Œæˆå•è¯</span><span id="statWords" style="color: #4CAF50; font-weight: bold;">0</span></div>
                <div style="display: flex; justify-content: space-between;"><span>é”™è¯¯æ¬¡æ•°</span><span id="statMistakes" style="color: #ff9800; font-weight: bold;">0</span></div>
                <div style="display: flex; justify-content: space-between;"><span>æ­»äº¡æ¬¡æ•°</span><span id="statDeaths" style="color: #f44336; font-weight: bold;">0</span></div>
            </div>
            <button class="overlay-btn" style="width: 100%; margin-top: 20px;" onclick="hideDailyStats()">å…³é—­</button>
        </div>
    </div>

    <!-- ç»“ç®—å¡ç‰‡ -->
    <div id="settlementCard" class="hidden">
        <h2 id="settlementTitle" style="color: #4CAF50; margin-top: 0;">Cluster Complete</h2>
        <p id="settlementStats" style="font-size: 24px; margin: 20px 0;">Accuracy: 100%</p>
        <p style="font-size: 14px; color: #aaa;">Press Space to continue</p>
    </div>

    <!-- å¿«é€Ÿè®°å¿†è¯¢é—®å±‚ -->
    <div id="quickMemoPromptOverlay" class="overlay hidden">
        <div class="overlay-content">
            <h2 style="color: #4CAF50; margin-top: 0;">æ–°çš„ä¸€ç»„å•è¯å³å°†å¼€å§‹</h2>
            <p style="font-size: 18px; margin: 20px 0; color: #ccc;">æ˜¯å¦éœ€è¦å…ˆå¿«é€Ÿæµè§ˆå¹¶è®°å¿†æœ¬ç»„å•è¯ï¼Ÿ</p>
            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="btnQuickMemoYes" class="overlay-btn">éœ€è¦è®°å¿† (Y)</button>
                <button id="btnQuickMemoNo" class="overlay-btn secondary">ç›´æ¥å¼€å§‹ (N)</button>
            </div>
        </div>
    </div>

    <!-- å¿«é€Ÿè®°å¿†å±•ç¤ºå±‚ -->
    <div id="quickMemoDisplayOverlay" class="overlay hidden">
        <div class="overlay-content" style="max-width: 600px; width: 80%;">
            <h2 style="color: #4CAF50; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 10px;">æœ¬ç»„å•è¯é¢„è§ˆ</h2>
            <div id="quickMemoList" style="text-align: left; margin: 15px 0; max-height: 55vh; overflow-y: auto; font-size: 20px; line-height: 1.8;">
                <!-- å•è¯åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button id="btnQuickMemoDone" class="overlay-btn" style="width: 100%;">æˆ‘è®°ä½äº†ï¼Œå¼€å§‹æŒ‘æˆ˜ (Space)</button>
        </div>
    </div>

    <!-- å¼ºåˆ¶è®°å¿†å±‚ -->
    <div id="memorizeOverlay" class="overlay hidden">
        <h2 style="color: #f44336; font-size: 32px; margin-bottom: 10px;">é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œè¯·å¼ºåˆ¶è®°å¿†ï¼</h2>
        <div id="memoWord" style="font-size: 64px; color: #4CAF50; font-weight: bold; letter-spacing: 5px; margin: 20px 0;"></div>
        <div id="memoMeaning" style="font-size: 36px; margin-bottom: 40px;"></div>
        <div id="memoCountdown" style="font-size: 64px; font-weight: bold; color: #ff9800;">10</div>
    </div>

    <script>
        // --- 1. åˆå§‹åŒ– Canvas ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let gameStateReady = false;
        
        function resize() {
            const prevWidth = width;
            const prevHeight = height;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            if (gameStateReady && Number.isFinite(prevWidth) && Number.isFinite(prevHeight)) {
                adjustTreePositionOnResize(prevWidth, prevHeight, width, height);
            }
        }
        
        window.addEventListener('resize', resize);
        resize();

        // --- 2. æ ¸å¿ƒæ•°æ®ä¸çŠ¶æ€ç®¡ç† ---

        // --- éŸ³æ•ˆç³»ç»Ÿï¼šå·´èµ« Cello Suite No.1 PrÃ©lude ---
        let audioCtx = null;
        let preludeIndex = 0;
        const preludeNotes = [
            // Measure 1-2: G major arpeggio pattern
            98.00, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            98.00, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            // Measure 3-4: C major / Am
            110.00, 164.81, 261.63, 246.94, 261.63, 164.81, 261.63, 164.81,
            110.00, 164.81, 261.63, 246.94, 261.63, 164.81, 261.63, 164.81,
            // Measure 5-6: D major
            123.47, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            130.81, 164.81, 220.00, 196.00, 220.00, 164.81, 220.00, 164.81,
            // Measure 7-8: G -> D7
            123.47, 146.83, 196.00, 174.61, 196.00, 146.83, 196.00, 146.83,
            98.00, 123.47, 174.61, 146.83, 174.61, 123.47, 174.61, 123.47,
            // Measure 9-10
            98.00, 146.83, 246.94, 220.00, 246.94, 146.83, 246.94, 146.83,
            98.00, 164.81, 261.63, 246.94, 261.63, 164.81, 261.63, 164.81,
            // Measure 11-12: rising line
            110.00, 185.00, 293.66, 261.63, 293.66, 185.00, 293.66, 185.00,
            146.83, 220.00, 293.66, 261.63, 293.66, 220.00, 293.66, 220.00,
        ];

        function ensureAudioCtx() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playCelloNote(freq, duration = 0.25) {
            ensureAudioCtx();
            const t = audioCtx.currentTime;

            // åŸºé¢‘ + æ³›éŸ³æ¨¡æ‹Ÿå¤§æç´
            const gains = [1, 0.5, 0.3, 0.15, 0.08];
            const masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(0, t);
            masterGain.gain.linearRampToValueAtTime(0.15, t + 0.02);
            masterGain.gain.setValueAtTime(0.15, t + duration * 0.5);
            masterGain.gain.exponentialRampToValueAtTime(0.001, t + duration);
            masterGain.connect(audioCtx.destination);

            gains.forEach((g, i) => {
                const osc = audioCtx.createOscillator();
                const oscGain = audioCtx.createGain();
                osc.type = i === 0 ? 'sawtooth' : 'triangle';
                osc.frequency.setValueAtTime(freq * (i + 1), t);
                oscGain.gain.setValueAtTime(g * 0.3, t);
                osc.connect(oscGain);
                oscGain.connect(masterGain);
                osc.start(t);
                osc.stop(t + duration + 0.05);
            });
        }

        function playCorrectNote() {
            const freq = preludeNotes[preludeIndex % preludeNotes.length];
            preludeIndex++;
            playCelloNote(freq, 0.22);
        }

        function playWrongNote() {
            ensureAudioCtx();
            playCelloNote(73.42, 0.35); // D2 ä½æ²‰
        }

        function playCompleteChord() {
            playCelloNote(196.00, 0.5);
            setTimeout(() => playCelloNote(246.94, 0.5), 80);
            setTimeout(() => playCelloNote(293.66, 0.6), 160);
        }

        function playAutoClick() {
            ensureAudioCtx();
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = 1200;
            gain.gain.setValueAtTime(0.03, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.04);
        }

        function speakWordPhrase(text) {
            if (!('speechSynthesis' in window)) return;
            const value = String(text || '').trim();
            if (!value) return;
            const spoken = value
                .replace(/\bsth\./gi, 'something')
                .replace(/\bsb\./gi, 'somebody');
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(spoken);
            utterance.lang = 'en-US';
            utterance.rate = 0.95;
            utterance.pitch = 1;
            utterance.volume = 1;
            window.speechSynthesis.speak(utterance);
        }

        let dictionaries = {};
        const CLUSTER_SIZE_MIN = 3;
        const CLUSTER_SIZE_MAX = 30;
        const DEFAULT_CLUSTER_SIZE = 7;
        const BACKUP_FORMAT_VERSION = 1;
        
        let currentDictionary = null;
        let currentDictName = '';

        function getLearningProgress(dictName) {
            const saved = localStorage.getItem('wordVineProgress');
            if (!saved) return {};
            try {
                const all = JSON.parse(saved);
                return all[dictName] || {};
            } catch(e) { return {}; }
        }

        function markWordLearned(dictName, word) {
            let all = {};
            const saved = localStorage.getItem('wordVineProgress');
            if (saved) { try { all = JSON.parse(saved); } catch(e) {} }
            if (!all[dictName]) all[dictName] = {};
            all[dictName][word] = Date.now();
            localStorage.setItem('wordVineProgress', JSON.stringify(all));
        }

        function getLearnedCount(dictName) {
            const prog = getLearningProgress(dictName);
            return Object.keys(prog).length;
        }

        function clearLearningProgress(dictName) {
            let all = {};
            const saved = localStorage.getItem('wordVineProgress');
            if (saved) { try { all = JSON.parse(saved); } catch(e) {} }
            delete all[dictName];
            localStorage.setItem('wordVineProgress', JSON.stringify(all));
        }

        function normalizeClusterSize(value) {
            const n = Number(value);
            if (!Number.isFinite(n)) return DEFAULT_CLUSTER_SIZE;
            return Math.max(CLUSTER_SIZE_MIN, Math.min(CLUSTER_SIZE_MAX, Math.round(n)));
        }

        function normalizeDictionaryEntries(raw) {
            const result = {};
            if (!raw || typeof raw !== 'object') return result;

            Object.keys(raw).forEach(name => {
                const source = raw[name];
                const list = [];

                if (Array.isArray(source)) {
                    source.forEach(item => {
                        if (item && typeof item.word === 'string' && typeof item.meaning === 'string') {
                            const word = item.word.trim();
                            const meaning = item.meaning.trim();
                            if (word && meaning) list.push({ word, meaning });
                        }
                    });
                } else if (source && typeof source === 'object') {
                    Object.keys(source).forEach(wordKey => {
                        const meaningVal = source[wordKey];
                        if (typeof wordKey === 'string' && typeof meaningVal === 'string') {
                            const word = wordKey.trim();
                            const meaning = meaningVal.trim();
                            if (word && meaning) list.push({ word, meaning });
                        }
                    });
                }

                if (list.length > 0) {
                    result[name] = list;
                }
            });

            return result;
        }

        function exportAllDataToFile() {
            const backup = {
                meta: {
                    app: 'Word Vine',
                    format: 'word-vine-backup',
                    version: BACKUP_FORMAT_VERSION,
                    exportedAt: new Date().toISOString()
                },
                data: {
                    dictionaries,
                    learningProgress: (() => {
                        const saved = localStorage.getItem('wordVineProgress');
                        if (!saved) return {};
                        try { return JSON.parse(saved) || {}; } catch (e) { return {}; }
                    })(),
                    dailyStats: (() => {
                        const saved = localStorage.getItem('wordVineDailyStats');
                        if (!saved) return { ...dailyStats };
                        try { return JSON.parse(saved) || { ...dailyStats }; } catch (e) { return { ...dailyStats }; }
                    })(),
                    settings: {
                        clusterSize: normalizeClusterSize(gameState.clusterSize)
                    }
                }
            };

            const json = JSON.stringify(backup, null, 2);
            const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const stamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
            a.href = url;
            a.download = `word-vine-backup-${stamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importAllDataObject(payload) {
            const data = payload && payload.data ? payload.data : payload;
            if (!data || typeof data !== 'object') {
                throw new Error('æ–‡ä»¶å†…å®¹æ— æ•ˆ');
            }

            const nextDictionaries = normalizeDictionaryEntries(data.dictionaries);
            const nextProgress = data.learningProgress && typeof data.learningProgress === 'object' ? data.learningProgress : {};
            const nextDailyStats = data.dailyStats && typeof data.dailyStats === 'object' ? data.dailyStats : {};
            const settings = data.settings && typeof data.settings === 'object' ? data.settings : {};

            dictionaries = nextDictionaries;
            localStorage.setItem('wordVineDicts', JSON.stringify(dictionaries));
            localStorage.setItem('wordVineProgress', JSON.stringify(nextProgress));

            const normalizedDaily = {
                date: typeof nextDailyStats.date === 'string' ? nextDailyStats.date : new Date().toDateString(),
                wordsCompleted: Number(nextDailyStats.wordsCompleted) || 0,
                mistakes: Number(nextDailyStats.mistakes) || 0,
                deaths: Number(nextDailyStats.deaths) || 0
            };
            dailyStats.date = normalizedDaily.date;
            dailyStats.wordsCompleted = normalizedDaily.wordsCompleted;
            dailyStats.mistakes = normalizedDaily.mistakes;
            dailyStats.deaths = normalizedDaily.deaths;
            localStorage.setItem('wordVineDailyStats', JSON.stringify(normalizedDaily));

            const normalizedClusterSize = normalizeClusterSize(settings.clusterSize);
            gameState.clusterSize = normalizedClusterSize;
            const selectedDictName = typeof settings.selectedDictName === 'string' ? settings.selectedDictName : '';
            localStorage.setItem('wordVineSettings', JSON.stringify({ clusterSize: normalizedClusterSize, selectedDictName }));
            const clusterInput = document.getElementById('clusterSizeInput');
            if (clusterInput) clusterInput.value = String(normalizedClusterSize);

            updateDictSelect(selectedDictName);
            saveGameSettings();
        }

        function saveGameSettings() {
            const select = document.getElementById('dictSelect');
            const selectedDictName = select ? (select.value || '') : '';
            localStorage.setItem('wordVineSettings', JSON.stringify({
                clusterSize: gameState.clusterSize,
                selectedDictName
            }));
        }

        function loadGameSettings() {
            let clusterSize = DEFAULT_CLUSTER_SIZE;
            let selectedDictName = '';
            const saved = localStorage.getItem('wordVineSettings');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    clusterSize = normalizeClusterSize(parsed.clusterSize);
                    if (typeof parsed.selectedDictName === 'string') {
                        selectedDictName = parsed.selectedDictName;
                    }
                } catch (e) {}
            }
            gameState.clusterSize = clusterSize;
            const input = document.getElementById('clusterSizeInput');
            if (input) input.value = String(clusterSize);
            updateDictSelect(selectedDictName);
        }

        // åŠ è½½æœ¬åœ°ç¼“å­˜çš„è¯åº“
        function loadDictionaries() {
            const saved = localStorage.getItem('wordVineDicts');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    dictionaries = parsed;
                } catch (e) {
                    console.error("Failed to load dictionaries", e);
                }
            }
            updateDictSelect();
        }

        // æ›´æ–°ä¸‹æ‹‰èœå•
        function updateDictSelect(preferredName = '') {
            const select = document.getElementById('dictSelect');
            const previousSelected = preferredName || select.value;
            select.innerHTML = '';
            const names = Object.keys(dictionaries);
            for (const name in dictionaries) {
                const option = document.createElement('option');
                option.value = name;
                const learned = getLearnedCount(name);
                const total = dictionaries[name].length;
                option.textContent = `${name} (${learned}/${total})`;
                select.appendChild(option);
            }

            if (names.length > 0) {
                if (previousSelected && names.includes(previousSelected)) {
                    select.value = previousSelected;
                } else {
                    select.value = names[0];
                }
            }

            renderDictionaryManagerList();
        }

        function renderDictionaryManagerList() {
            const list = document.getElementById('dictManageList');
            if (!list) return;
            list.innerHTML = '';

            const names = Object.keys(dictionaries);
            if (names.length === 0) {
                const empty = document.createElement('div');
                empty.style.cssText = 'color:#888; font-size:13px; text-align:left; padding:6px 2px;';
                empty.textContent = 'æš‚æ— è¯åº“';
                list.appendChild(empty);
                return;
            }

            names.forEach((name) => {
                const row = document.createElement('div');
                row.style.cssText = 'display:flex; align-items:center; justify-content:space-between; gap:8px; background:#1a1a1a; border:1px solid #333; border-radius:6px; padding:8px;';

                const title = document.createElement('div');
                title.style.cssText = 'color:#ddd; font-size:13px; flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; text-align:left;';
                title.textContent = `${name} (${getLearnedCount(name)}/${dictionaries[name].length})`;

                const actions = document.createElement('div');
                actions.style.cssText = 'display:flex; gap:6px;';

                const renameBtn = document.createElement('button');
                renameBtn.type = 'button';
                renameBtn.dataset.action = 'rename';
                renameBtn.dataset.dict = name;
                renameBtn.textContent = 'æ”¹å';
                renameBtn.style.cssText = 'background:#1976d2; margin:0; padding:6px 10px; font-size:12px;';

                const resetBtn = document.createElement('button');
                resetBtn.type = 'button';
                resetBtn.dataset.action = 'reset';
                resetBtn.dataset.dict = name;
                resetBtn.textContent = 'é‡ç½®';
                resetBtn.style.cssText = 'background:#ff9800; margin:0; padding:6px 10px; font-size:12px;';

                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.dataset.action = 'delete';
                deleteBtn.dataset.dict = name;
                deleteBtn.textContent = 'åˆ é™¤';
                deleteBtn.style.cssText = 'background:#f44336; margin:0; padding:6px 10px; font-size:12px;';

                actions.appendChild(renameBtn);
                actions.appendChild(resetBtn);
                actions.appendChild(deleteBtn);
                row.appendChild(title);
                row.appendChild(actions);
                list.appendChild(row);
            });
        }

        function renameDictionary(dictName) {
            if (!dictionaries[dictName]) return;
            const input = prompt(`è¯·è¾“å…¥æ–°çš„è¯åº“åç§°ï¼š`, dictName);
            if (input === null) return;

            const nextName = input.trim();
            if (!nextName) {
                alert('è¯åº“åç§°ä¸èƒ½ä¸ºç©º');
                return;
            }
            if (nextName === dictName) return;
            if (dictionaries[nextName]) {
                alert(`è¯åº“åç§° "${nextName}" å·²å­˜åœ¨`);
                return;
            }

            dictionaries[nextName] = dictionaries[dictName];
            delete dictionaries[dictName];
            localStorage.setItem('wordVineDicts', JSON.stringify(dictionaries));

            let allProgress = {};
            const savedProgress = localStorage.getItem('wordVineProgress');
            if (savedProgress) {
                try { allProgress = JSON.parse(savedProgress) || {}; } catch (e) {}
            }
            if (allProgress[dictName]) {
                allProgress[nextName] = allProgress[dictName];
                delete allProgress[dictName];
                localStorage.setItem('wordVineProgress', JSON.stringify(allProgress));
            }

            if (currentDictName === dictName) {
                currentDictName = nextName;
            }

            updateDictSelect(nextName);
            saveGameSettings();
        }

        function resetDictionaryRecords(dictName) {
            if (!dictionaries[dictName]) return;
            const ok = confirm(`å°†æ¸…é™¤è¯åº“ "${dictName}" çš„æ‰€æœ‰å­¦ä¹ è®°å½•ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`);
            if (!ok) return;
            dailyStats.wordsCompleted = 0;
            dailyStats.mistakes = 0;
            dailyStats.deaths = 0;
            saveDailyStats();
            gameState.historicalMistakes = {};
            gameState.wordMistakeMap = {};
            clearLearningProgress(dictName);
            updateDictSelect();
            alert(`è¯åº“ "${dictName}" çš„å­¦ä¹ è®°å½•å·²é‡ç½®ï¼`);
        }

        function deleteDictionary(dictName) {
            if (!dictionaries[dictName]) return;
            const ok = confirm(`åˆ é™¤è¯åº“ "${dictName}" åæ— æ³•æ¢å¤ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`);
            if (!ok) return;
            delete dictionaries[dictName];
            localStorage.setItem('wordVineDicts', JSON.stringify(dictionaries));
            clearLearningProgress(dictName);
            updateDictSelect();
        }

        // å¯¼å…¥æ–°è¯åº“
        document.getElementById('importBtn').addEventListener('click', () => {
            const nameInput = document.getElementById('dictNameInput').value.trim();
            const dataInput = document.getElementById('importData').value.trim();
            const msgDiv = document.getElementById('importMsg');
            
            if (!nameInput) {
                msgDiv.textContent = "è¯·è¾“å…¥è¯åº“åç§°";
                msgDiv.style.color = "#f44336";
                return;
            }
            if (!dataInput) {
                msgDiv.textContent = "è¯·è¾“å…¥JSONæ•°æ®";
                msgDiv.style.color = "#f44336";
                return;
            }

            try {
                const parsedData = JSON.parse(dataInput);
                const newDict = [];
                
                // éªŒè¯å¹¶è½¬æ¢æ ¼å¼
                for (const key in parsedData) {
                    if (typeof key === 'string' && typeof parsedData[key] === 'string') {
                        const trimmed = key.trim();
                        if (trimmed.length > 0 && /[a-zA-Z]/.test(trimmed)) {
                            newDict.push({ word: trimmed, meaning: parsedData[key] });
                        }
                    }
                }

                if (newDict.length === 0) {
                    throw new Error("æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„å•è¯æ•°æ®");
                }

                // ä¿å­˜åˆ°å†…å­˜å’Œ localStorage
                dictionaries[nameInput] = newDict;
                
                localStorage.setItem('wordVineDicts', JSON.stringify(dictionaries));
                
                updateDictSelect(nameInput);
                saveGameSettings();
                
                msgDiv.textContent = `æˆåŠŸå¯¼å…¥ ${newDict.length} ä¸ªå•è¯ï¼`;
                msgDiv.style.color = "#4CAF50";
                
                // æ¸…ç©ºè¾“å…¥æ¡†
                document.getElementById('dictNameInput').value = '';
                document.getElementById('importData').value = '';
                
            } catch (e) {
                msgDiv.textContent = "JSON æ ¼å¼é”™è¯¯æˆ–æ•°æ®æ— æ•ˆ: " + e.message;
                msgDiv.style.color = "#f44336";
            }
        });

        // ä»æ–‡ä»¶åŠ è½½
        document.getElementById('loadFileBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    // å°è¯•è§£æä»¥éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆ JSON
                    JSON.parse(content);
                    
                    // å¡«å……åˆ°æ–‡æœ¬æ¡†
                    document.getElementById('importData').value = content;
                    
                    // å¦‚æœæ²¡æœ‰è¾“å…¥åç§°ï¼Œä½¿ç”¨æ–‡ä»¶åï¼ˆå»æ‰æ‰©å±•åï¼‰
                    const nameInput = document.getElementById('dictNameInput');
                    if (!nameInput.value) {
                        nameInput.value = file.name.replace(/\.[^/.]+$/, "");
                    }
                    
                    document.getElementById('importMsg').textContent = "æ–‡ä»¶åŠ è½½æˆåŠŸï¼Œè¯·ç‚¹å‡»'ä¿å­˜å¹¶å¯¼å…¥'";
                    document.getElementById('importMsg').style.color = "#4CAF50";
                } catch (err) {
                    document.getElementById('importMsg').textContent = "æ–‡ä»¶å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼";
                    document.getElementById('importMsg').style.color = "#f44336";
                }
                // æ¸…ç©º input ä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
                event.target.value = '';
            };
            reader.readAsText(file);
        });

        document.getElementById('exportProgressBtn').addEventListener('click', () => {
            const msgDiv = document.getElementById('progressTransferMsg');
            try {
                exportAllDataToFile();
                msgDiv.textContent = 'å¯¼å‡ºæˆåŠŸ';
                msgDiv.style.color = '#4CAF50';
            } catch (e) {
                msgDiv.textContent = 'å¯¼å‡ºå¤±è´¥: ' + e.message;
                msgDiv.style.color = '#f44336';
            }
        });

        document.getElementById('importProgressBtn').addEventListener('click', () => {
            document.getElementById('progressFileInput').click();
        });

        document.getElementById('progressFileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const msgDiv = document.getElementById('progressTransferMsg');
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const payload = JSON.parse(e.target.result);
                    const data = payload && payload.data ? payload.data : payload;
                    const incomingDicts = normalizeDictionaryEntries(data && data.dictionaries ? data.dictionaries : {});
                    const dictCount = Object.keys(incomingDicts).length;
                    const wordCount = Object.values(incomingDicts).reduce((sum, list) => sum + list.length, 0);
                    const ok = confirm(`å°†è¦†ç›–æœ¬åœ°è¯åº“ä¸å­¦ä¹ è¿›åº¦ã€‚\nå³å°†å¯¼å…¥ï¼š${dictCount} ä¸ªè¯åº“ï¼Œ${wordCount} ä¸ªè¯æ¡ã€‚\næ˜¯å¦ç»§ç»­ï¼Ÿ`);
                    if (!ok) {
                        msgDiv.textContent = 'å·²å–æ¶ˆå¯¼å…¥';
                        msgDiv.style.color = '#aaa';
                        return;
                    }
                    importAllDataObject(payload);
                    msgDiv.textContent = 'å¯¼å…¥æˆåŠŸï¼Œå·²æ¢å¤è¯åº“å’Œå­¦ä¹ è¿›åº¦';
                    msgDiv.style.color = '#4CAF50';
                } catch (err) {
                    msgDiv.textContent = 'å¯¼å…¥å¤±è´¥: ' + err.message;
                    msgDiv.style.color = '#f44336';
                }
                event.target.value = '';
            };
            reader.readAsText(file);
        });

        const dictManageList = document.getElementById('dictManageList');
        if (dictManageList) {
            dictManageList.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-action][data-dict]');
                if (!btn) return;
                const dictName = btn.dataset.dict;
                if (!dictName) return;
                if (btn.dataset.action === 'rename') {
                    renameDictionary(dictName);
                } else if (btn.dataset.action === 'reset') {
                    resetDictionaryRecords(dictName);
                } else if (btn.dataset.action === 'delete') {
                    deleteDictionary(dictName);
                }
            });
        }

        const dictSelect = document.getElementById('dictSelect');
        if (dictSelect) {
            dictSelect.addEventListener('change', () => {
                saveGameSettings();
            });
        }

        // å¼€å§‹æ¸¸æˆæŒ‰é’®
        document.getElementById('startBtn').addEventListener('click', () => {
            const selectedName = document.getElementById('dictSelect').value;
            if (!selectedName || !dictionaries[selectedName]) {
                alert("è¯·å…ˆå¯¼å…¥ä¸€ä¸ªè¯åº“ï¼");
                return;
            }

            const clusterInput = document.getElementById('clusterSizeInput');
            const clusterSize = normalizeClusterSize(clusterInput ? clusterInput.value : DEFAULT_CLUSTER_SIZE);
            gameState.clusterSize = clusterSize;
            if (clusterInput) clusterInput.value = String(clusterSize);
            saveGameSettings();

            currentDictName = selectedName;
            const fullDict = dictionaries[selectedName];
            const progress = getLearningProgress(selectedName);
            currentDictionary = fullDict.filter(item => !progress[item.word]);
            
            if (currentDictionary.length === 0) {
                alert("è¯¥è¯åº“æ‰€æœ‰å•è¯å·²å­¦å®Œï¼å¯ä»¥é‡ç½®å­¦ä¹ è®°å½•é‡æ–°å¼€å§‹ã€‚");
                return;
            }
            
            currentDictionary.sort(() => Math.random() - 0.5);
            
            document.getElementById('menuLayer').classList.add('hidden');
            document.getElementById('uiLayer').classList.remove('hidden');
            
            initGame();
            if (!gameLoopRunning) {
                gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        });

        document.getElementById('openSettingsBtn').addEventListener('click', () => {
            showMenuSettingsView();
        });

        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            showMenuMainView();
        });

        const gameState = {
            currentWordIndex: 0,
            currentStepIndex: 0,
            score: 0,
            combo: 1,
            cameraY: 0,
            targetCameraY: 0,
            cameraX: 0,
            targetCameraX: 0,
            cameraZoom: 1,
            targetCameraZoom: 1,
            bgHue: 120, // åˆå§‹ç»¿è‰²è‰²ç›¸
            targetBgHue: 120,
            isTransitioning: false, // æ˜¯å¦åœ¨å•è¯åˆ‡æ¢çš„è¿‡æ¸¡æœŸ
            isSettling: false, // æ˜¯å¦åœ¨ç°‡ç»“ç®—çŠ¶æ€
            isPromptingMemo: false, // æ˜¯å¦åœ¨è¯¢é—®å¿«é€Ÿè®°å¿†
            isShowingMemo: false, // æ˜¯å¦åœ¨å±•ç¤ºå¿«é€Ÿè®°å¿†
            nodes: [], // å­˜å‚¨è—¤è”“ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹
            activeOptions: [], // å½“å‰å±å¹•ä¸Šå¯ä¾›é€‰æ‹©çš„èŠ‚ç‚¹ï¼ˆæ­£ç¡®+å¹²æ‰°ï¼‰
            fadingNodes: [], // æ­£åœ¨æ·¡å‡ºçš„é”™è¯¯èŠ‚ç‚¹
            mistakeCount: 0,
            lastMistakeTime: 0,
            currentWordStartIndex: 0,
            clusterSize: 10, // æ¯ä¸ªç°‡çš„å•è¯æ•°é‡
            wordsCompletedInCluster: 0,
            clusterMistakes: 0, // å½“å‰ç°‡çš„æ€»é”™è¯¯æ•°
            historicalMistakes: {}, // è®°å½•æ›¾é€‰é”™çš„å­—æ¯ {word: [wrongLetters]}
            wordMistakeMap: {}, // è®°å½•æ¯ä¸ªå•è¯çš„é”™è¯¯æ¬¡æ•°ï¼Œç”¨äºæ‰æ ¹æŒ‘æˆ˜
            wordLabels: [],
            labelHitAreas: [],
            clickEffects: [],
            parsedSteps: [],
            isAutoDrawing: false,
            isDragging: false,
            dragStartY: 0,
            dragStartCameraY: 0,
            dragMoved: false,
            isBrowsing: false
        };

        const clusterSizeInput = document.getElementById('clusterSizeInput');
        if (clusterSizeInput) {
            clusterSizeInput.addEventListener('change', () => {
                const value = normalizeClusterSize(clusterSizeInput.value);
                clusterSizeInput.value = String(value);
                gameState.clusterSize = value;
                saveGameSettings();
            });
        }

        gameStateReady = true;

        function adjustTreePositionOnResize(prevW, prevH, nextW, nextH) {
            const dx = (nextW - prevW) * 0.5;
            const dy = (nextH - prevH) * 0.5;
            if (dx === 0 && dy === 0) return;

            const shiftNodes = (arr) => {
                arr.forEach(node => {
                    node.x += dx;
                    node.y += dy;
                });
            };

            shiftNodes(gameState.nodes);
            shiftNodes(gameState.activeOptions);
            shiftNodes(gameState.fadingNodes);

            gameState.wordLabels.forEach(label => {
                label.x += dx;
                label.y += dy;
            });
        }

        const dailyStats = {
            date: new Date().toDateString(),
            wordsCompleted: 0,
            mistakes: 0,
            deaths: 0
        };

        function loadDailyStats() {
            const saved = localStorage.getItem('wordVineDailyStats');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (parsed.date === new Date().toDateString()) {
                        dailyStats.wordsCompleted = parsed.wordsCompleted || 0;
                        dailyStats.mistakes = parsed.mistakes || 0;
                        dailyStats.deaths = parsed.deaths || 0;
                    }
                } catch(e) {}
            }
        }

        function saveDailyStats() {
            dailyStats.date = new Date().toDateString();
            localStorage.setItem('wordVineDailyStats', JSON.stringify(dailyStats));
        }

        function showDailyStats() {
            const overlay = document.getElementById('dailyStatsOverlay');
            document.getElementById('statWords').innerText = dailyStats.wordsCompleted;
            document.getElementById('statMistakes').innerText = dailyStats.mistakes;
            document.getElementById('statDeaths').innerText = dailyStats.deaths;
            overlay.classList.remove('hidden');
            gameState.isTransitioning = true;
        }

        function showMenuMainView() {
            document.getElementById('menuMainView').classList.remove('hidden');
            document.getElementById('menuSettingsView').classList.add('hidden');
        }

        function showMenuSettingsView() {
            document.getElementById('menuMainView').classList.add('hidden');
            document.getElementById('menuSettingsView').classList.remove('hidden');
        }

        function hideDailyStats() {
            document.getElementById('dailyStatsOverlay').classList.add('hidden');
            gameState.isTransitioning = false;
        }

        function confirmExit() {
            const ok = confirm('ç¡®å®šé€€å‡ºåˆ°ä¸»ç•Œé¢å—ï¼Ÿå½“å‰è¿›åº¦å·²è‡ªåŠ¨ä¿å­˜ã€‚');
            if (!ok) return;
            gameLoopRunning = false;
            document.getElementById('uiLayer').classList.add('hidden');
            document.getElementById('menuLayer').classList.remove('hidden');
            showMenuMainView();
            updateDictSelect();
        }

        // èŠ‚ç‚¹ç±»
        class Node {
            constructor(x, y, letter, isCorrect, parent = null) {
                this.x = x;
                this.y = y;
                this.letter = letter;
                this.isCorrect = isCorrect;
                this.parent = parent;
                this.state = 'active';
                this.radius = 20;
                this.alpha = 1;
                this.scale = 0;
                this.targetScale = 1;
                this.nodeType = 'letter';
            }

            update(dt) {
                // ç®€å•çš„å¼¹æ€§åŠ¨ç”»
                this.scale += (this.targetScale - this.scale) * 0.1;
                
                if (this.state === 'fading') {
                    this.alpha -= 0.05;
                    if (this.alpha <= 0) {
                        this.alpha = 0;
                    }
                }
            }
        }

        const CAPSULE_PLACEHOLDERS = ['sth.', 'sb.', 'adj.', 'adv.', 'prep.', 'pron.', 'conj.'];

        function formatWord(w) {
            if (!w) return '';
            return w.split(' ').map(part => {
                if (CAPSULE_PLACEHOLDERS.includes(part.toLowerCase())) return part.toLowerCase();
                if (part.length === 0) return part;
                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
            }).join(' ');
        }

        function parsePhrase(phrase) {
            const steps = [];
            let i = 0;
            const sorted = [...CAPSULE_PLACEHOLDERS].sort((a, b) => b.length - a.length);
            while (i < phrase.length) {
                let found = false;
                for (const ph of sorted) {
                    const sub = phrase.substring(i, i + ph.length);
                    if (sub.toLowerCase() === ph.toLowerCase()) {
                        const before = i === 0 || !/[a-zA-Z]/.test(phrase[i - 1]);
                        const after = i + ph.length >= phrase.length || !/[a-zA-Z]/.test(phrase[i + ph.length]);
                        if (before && after) {
                            steps.push({ type: 'auto', display: sub, subType: 'capsule' });
                            i += ph.length;
                            found = true;
                            break;
                        }
                    }
                }
                if (found) continue;
                if (phrase[i] === '(') {
                    const close = phrase.indexOf(')', i);
                    if (close !== -1) {
                        steps.push({ type: 'auto', display: phrase.substring(i, close + 1), subType: 'bracket' });
                        i = close + 1;
                        continue;
                    }
                }
                if (/[a-zA-Z]/.test(phrase[i])) {
                    steps.push({ type: 'input', char: phrase[i].toUpperCase(), displayChar: phrase[i].toLowerCase() });
                    i++;
                } else if (phrase[i] === ' ') {
                    steps.push({ type: 'auto', display: ' ', subType: 'space' });
                    i++;
                } else {
                    steps.push({ type: 'auto', display: phrase[i], subType: 'symbol' });
                    i++;
                }
            }
            return steps;
        }

        function advanceAfterStep(parentNode) {
            const nextIdx = gameState.currentStepIndex + 1;
            if (nextIdx >= gameState.parsedSteps.length) {
                completeWord();
                return;
            }
            if (gameState.parsedSteps[nextIdx].type === 'auto') {
                processAutoSteps(parentNode);
            } else {
                generateOptions(parentNode);
            }
        }

        function processAutoSteps(parentNode) {
            gameState.isAutoDrawing = true;
            gameState.activeOptions = [];
            const autoSteps = [];
            let idx = gameState.currentStepIndex + 1;
            while (idx < gameState.parsedSteps.length && gameState.parsedSteps[idx].type === 'auto') {
                autoSteps.push({ step: gameState.parsedSteps[idx], idx });
                idx++;
            }
            let current = parentNode;
            let delay = 0;
            autoSteps.forEach((item, i) => {
                delay += item.step.subType === 'space' ? 80 : 150;
                setTimeout(() => {
                    const dist = item.step.subType === 'space' ? 40 : 55;
                    let x = current.x + (Math.random() - 0.5) * 15;
                    const y = current.y - dist;
                    const margin = 40;
                    x = Math.max(margin, Math.min(width - margin, x));
                    const node = new Node(x, y, item.step.display, true, current);
                    node.state = 'completed';
                    node.nodeType = item.step.subType;
                    node.scale = 0;
                    node.targetScale = 1;
                    gameState.nodes.push(node);
                    gameState.currentStepIndex = item.idx;
                    current = node;
                    gameState.targetCameraY = height * 0.5 - node.y;
                    gameState.targetCameraX = width * 0.5 - node.x;
                    playAutoClick();
                    if (i === autoSteps.length - 1) {
                        gameState.isAutoDrawing = false;
                        const next = gameState.parsedSteps[gameState.currentStepIndex + 1];
                        if (next && next.type === 'input') {
                            generateOptions(node);
                        } else if (!next) {
                            completeWord();
                        }
                        updateUI();
                    }
                }, delay);
            });
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameState.currentWordIndex = 0;
            gameState.currentStepIndex = 0;
            gameState.score = 0;
            gameState.combo = 1;
            gameState.nodes = [];
            gameState.activeOptions = [];
            gameState.fadingNodes = [];
            gameState.mistakeCount = 0;
            gameState.lastMistakeTime = 0;
            gameState.currentWordStartIndex = 0;
            gameState.wordsCompletedInCluster = 0;
            gameState.clusterMistakes = 0;
            gameState.historicalMistakes = {};
            gameState.wordMistakeMap = {};
            gameState.wordLabels = [];
            gameState.clickEffects = [];
            gameState.cameraZoom = 1;
            gameState.targetCameraZoom = 1;
            gameState.bgHue = 120;
            gameState.targetBgHue = 120;
            gameState.isSettling = false;
            gameState.isAutoDrawing = false;
            gameState.isPromptingMemo = false;
            gameState.isShowingMemo = false;
            
            promptQuickMemo();
        }

        function startGameplay() {
            const firstPhrase = currentDictionary[gameState.currentWordIndex].word;
            gameState.parsedSteps = parsePhrase(firstPhrase);
            gameState.currentStepIndex = 0;

            const firstStep = gameState.parsedSteps[0];
            const rootNode = new Node(width / 2, height * 0.8, firstStep.char, true);
            rootNode.state = 'completed';
            rootNode.scale = 1;
            gameState.nodes.push(rootNode);
            
            gameState.cameraY = 0;
            gameState.targetCameraY = 0;
            gameState.cameraX = 0;
            gameState.targetCameraX = 0;

            advanceAfterStep(rootNode);
            updateUI();
            initProgressGauge();
        }

        function initProgressGauge() {
            const gauge = document.getElementById('progressGauge');
            gauge.innerHTML = '';
            for (let i = 0; i < gameState.clusterSize; i++) {
                const dot = document.createElement('div');
                dot.className = 'gauge-dot';
                if (i === 0) dot.classList.add('current');
                gauge.appendChild(dot);
            }
        }

        function updateProgressGauge() {
            const dots = document.querySelectorAll('.gauge-dot');
            dots.forEach((dot, index) => {
                dot.className = 'gauge-dot'; // reset
                if (index < gameState.wordsCompletedInCluster) {
                    dot.classList.add('completed');
                } else if (index === gameState.wordsCompletedInCluster) {
                    dot.classList.add('current');
                }
            });
            
            // æ›´æ–°æ–‡å­—è¿›åº¦
            const totalWords = dictionaries[currentDictName] ? dictionaries[currentDictName].length : currentDictionary.length;
            const learnedWords = getLearnedCount(currentDictName);
            document.getElementById('progressDisplay').innerText = `${learnedWords}/${totalWords}`;
        }

        // --- æ¸¸æˆä¸»å¾ªç¯ ---
        let lastTime = 0;
        let gameLoopRunning = false;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            if (gameLoopRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        function update(dt) {
            if (!gameState.isDragging && !gameState.isBrowsing) {
                gameState.cameraY += (gameState.targetCameraY - gameState.cameraY) * 0.1;
            }
            gameState.cameraX += (gameState.targetCameraX - gameState.cameraX) * 0.1;
            gameState.cameraZoom += (gameState.targetCameraZoom - gameState.cameraZoom) * 0.05;
            gameState.bgHue += (gameState.targetBgHue - gameState.bgHue) * 0.02;

            // æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€
            gameState.nodes.forEach(node => node.update(dt));
            gameState.activeOptions.forEach(node => node.update(dt));
            gameState.fadingNodes.forEach(node => node.update(dt));
            updateClickEffects(dt);
            
            // æ¸…ç†å®Œå…¨é€æ˜çš„èŠ‚ç‚¹
            gameState.fadingNodes = gameState.fadingNodes.filter(node => node.alpha > 0);
        }

        function draw() {
            // æ¸…ç©ºç”»å¸ƒï¼Œä½¿ç”¨åŠ¨æ€è‰²ç›¸
            ctx.fillStyle = `hsl(${gameState.bgHue}, 20%, 8%)`;
            ctx.fillRect(0, 0, width, height);
            
            // ç»˜åˆ¶åŠ¨æ€èƒŒæ™¯ç½‘æ ¼
            drawGrid();

            // åº”ç”¨ç›¸æœºå˜æ¢
            ctx.save();
            
            // ç¼©æ”¾ä¸­å¿ƒç‚¹ä¸ºå±å¹•ä¸­å¿ƒ
            ctx.translate(width / 2, height / 2);
            ctx.scale(gameState.cameraZoom, gameState.cameraZoom);
            ctx.translate(-width / 2, -height / 2);
            
            ctx.translate(gameState.cameraX, gameState.cameraY);

            // ç»˜åˆ¶è—¤è”“å’ŒèŠ‚ç‚¹
            drawVines();
            drawNodes();
            drawClickEffects();

            ctx.restore();

            if (gameState.isBrowsing) {
                const btnW = 120, btnH = 40;
                const btnX = (width - btnW) / 2;
                const btnY = height - 60;
                ctx.fillStyle = 'rgba(76, 175, 80, 0.85)';
                ctx.beginPath();
                ctx.roundRect(btnX, btnY, btnW, btnH, 8);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 15px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('å›åˆ°å½“å‰', btnX + btnW / 2, btnY + btnH / 2);
                gameState._backBtnRect = { x: btnX, y: btnY, w: btnW, h: btnH };
            }
        }

        function drawGrid() {
            const gridSize = 50;
            const offsetX = 0;
            // åˆ©ç”¨å–æ¨¡è¿ç®—å®ç°æ— é™æ»šåŠ¨é”™è§‰
            const offsetY = gameState.cameraY % gridSize;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();

            // å‚ç›´çº¿
            for (let x = offsetX; x < width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }

            // æ°´å¹³çº¿
            for (let y = offsetY; y < height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }

            ctx.stroke();
        }

        function drawVines() {
            // ç»˜åˆ¶å·²å®Œæˆçš„è·¯å¾„ï¼ˆç²—å®çº¿ï¼Œå‘å…‰ï¼‰
            ctx.beginPath();
            ctx.strokeStyle = '#4CAF50'; // ç»¿è‰²è—¤è”“
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#4CAF50';

            if (gameState.nodes.length > 0) {
                ctx.moveTo(gameState.nodes[0].x, gameState.nodes[0].y);
                for (let i = 1; i < gameState.nodes.length; i++) {
                    const node = gameState.nodes[i];
                    
                    if (node.isNewTreeRoot) {
                        ctx.moveTo(node.x, node.y);
                    } else {
                        const prevNode = gameState.nodes[i - 1];
                        if (node.nodeType === 'space') {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([4, 6]);
                            ctx.lineWidth = 2;
                            ctx.moveTo(prevNode.x, prevNode.y);
                            ctx.lineTo(node.x, node.y);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([]);
                            ctx.lineWidth = 6;
                            ctx.moveTo(node.x, node.y);
                        } else {
                            const cpX = (prevNode.x + node.x) / 2;
                            const cpY = prevNode.y - 30;
                            ctx.quadraticCurveTo(cpX, cpY, node.x, node.y);
                        }
                    }
                }
            }
            ctx.stroke();
            
            // é‡ç½®é˜´å½±
            ctx.shadowBlur = 0;

            // ç»˜åˆ¶å½“å‰åˆ†æ”¯ï¼ˆç»†è™šçº¿ï¼ŒåŠé€æ˜ï¼‰
            if (gameState.nodes.length > 0 && !gameState.isTransitioning) {
                const lastNode = gameState.nodes[gameState.nodes.length - 1];
                
                gameState.activeOptions.forEach(option => {
                    ctx.beginPath();
                    if (option.state === 'wrong') {
                        ctx.strokeStyle = `rgba(244, 67, 54, ${option.alpha})`; // çº¢è‰²é”™è¯¯è·¯å¾„
                        ctx.setLineDash([]);
                    } else {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${option.alpha * 0.3})`; // ç™½è‰²è™šçº¿
                        ctx.setLineDash([5, 5]);
                    }
                    ctx.lineWidth = 2;
                    
                    const cpX = (lastNode.x + option.x) / 2;
                    const cpY = lastNode.y - 30;
                    ctx.moveTo(lastNode.x, lastNode.y);
                    ctx.quadraticCurveTo(cpX, cpY, option.x, option.y);
                    ctx.stroke();
                });
                ctx.setLineDash([]); // æ¢å¤å®çº¿
            }
        }

        function drawNodes() {
            gameState.labelHitAreas = [];

            gameState.nodes.forEach((node, index) => {
                const isLastNodeOfWord = index > 0 && (index === gameState.nodes.length - 1 || gameState.nodes[index + 1].isNewTreeRoot);
                if (isLastNodeOfWord && node.state === 'completed' && node.nodeType === 'letter') {
                    drawBloom(node);
                } else {
                    drawSingleNode(node, '#4CAF50', '#fff');
                }
            });
            
            // ç»˜åˆ¶å•è¯æ ‡ç­¾
            gameState.wordLabels.forEach(label => {
                const wordText = formatWord(label.word);
                const iconText = 'ğŸ”Š';
                const textX = label.x + 30;
                const wordY = label.y - 8;
                const meaningY = label.y + 10;

                ctx.save();
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.7)';
                ctx.fillText(wordText, textX, wordY);
                const wordWidth = ctx.measureText(wordText).width;

                ctx.font = '13px sans-serif';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.65)';
                ctx.fillText(iconText, textX + wordWidth + 8, wordY + 1);
                const iconWidth = ctx.measureText(iconText).width;

                ctx.font = '12px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillText(label.meaning, textX, meaningY);
                const meaningWidth = ctx.measureText(label.meaning).width;
                ctx.restore();

                gameState.labelHitAreas.push({
                    x: textX - 4,
                    y: wordY - 12,
                    w: Math.max(wordWidth + 8 + iconWidth, meaningWidth) + 8,
                    h: 32,
                    word: label.word
                });
            });
            
            // ç»˜åˆ¶æ­£åœ¨æ·¡å‡ºçš„é”™è¯¯èŠ‚ç‚¹
            gameState.fadingNodes.forEach(node => {
                drawSingleNode(node, `rgba(244, 67, 54, ${node.alpha})`, '#fff', node.alpha);
            });
            
            // ç»˜åˆ¶é€‰é¡¹èŠ‚ç‚¹
            if (!gameState.isTransitioning && !gameState.isSettling) {
                gameState.activeOptions.forEach(node => {
                    let bgColor = 'rgba(255, 255, 255, 0.1)';
                    let textColor = `rgba(255, 255, 255, ${node.alpha})`;
                    
                    if (node.state === 'wrong') {
                        bgColor = `rgba(244, 67, 54, ${node.alpha})`;
                        textColor = '#fff';
                    }
                    
                    drawSingleNode(node, bgColor, textColor, node.alpha);
                });
            }
        }

        function drawBloom(node) {
            ctx.save();
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);

            // ç»˜åˆ¶å‡ ä½•èŠ±è‹ (ç®€å•çš„å¤šè¾¹å½¢)
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(15, -10);
            ctx.lineTo(10, 15);
            ctx.lineTo(-10, 15);
            ctx.lineTo(-15, -10);
            ctx.closePath();
            
            ctx.fillStyle = '#8BC34A'; // æµ…ç»¿è‰²èŠ±è‹
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            
            // ç»˜åˆ¶å­—æ¯
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.letter, 0, 2);

            ctx.restore();
        }

        function drawSingleNode(node, bgColor, textColor, alpha = 1) {
            if (node.nodeType === 'capsule') { drawCapsuleNode(node, alpha); return; }
            if (node.nodeType === 'bracket') { drawBracketNode(node, alpha); return; }
            if (node.nodeType === 'symbol') { drawSymbolNode(node, alpha); return; }
            if (node.nodeType === 'space') return;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);

            ctx.beginPath();
            ctx.arc(0, 0, node.radius, 0, Math.PI * 2);
            ctx.fillStyle = bgColor;
            ctx.fill();
            
            if (node.state === 'completed') {
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#fff';
                ctx.stroke();
            }

            ctx.fillStyle = textColor;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.letter, 0, 2);

            ctx.restore();
        }

        function drawCapsuleNode(node, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);
            const text = node.letter;
            ctx.font = 'bold 11px Courier New';
            const tw = ctx.measureText(text).width;
            const pad = 10;
            const w = tw + pad * 2;
            const h = 22;
            ctx.beginPath();
            ctx.roundRect(-w / 2, -h / 2, w, h, h / 2);
            ctx.fillStyle = 'rgba(139,195,74,0.25)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(139,195,74,0.6)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#8BC34A';
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#8BC34A';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }

        function drawSymbolNode(node, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.letter, 0, 0);
            ctx.restore();
        }

        function drawBracketNode(node, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha * 0.6;
            ctx.translate(node.x, node.y);
            ctx.scale(node.scale, node.scale);
            const text = node.letter;
            ctx.font = '11px Courier New';
            const tw = ctx.measureText(text).width;
            const pad = 8;
            const w = tw + pad * 2;
            const h = 20;
            ctx.beginPath();
            ctx.roundRect(-w / 2, -h / 2, w, h, 4);
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.45)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }

        function createClickEffect(node, isCorrect) {
            const baseColor = isCorrect ? [76, 235, 120] : [255, 90, 90];
            const particles = [];
            const comboBoost = Math.min(2.2, 1 + Math.max(0, gameState.combo - 1) * 0.025);
            const count = Math.round((isCorrect ? 16 : 12) * comboBoost);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.45;
                const speed = ((isCorrect ? 2.5 : 2.1) + Math.random() * 2.2) * (0.9 + comboBoost * 0.25);
                particles.push({
                    x: node.x,
                    y: node.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: ((isCorrect ? 2.6 : 2.1) + Math.random() * 2) * (0.9 + comboBoost * 0.18),
                    alpha: 1,
                    drag: 0.965 + Math.random() * 0.015
                });
            }
            const baseLife = isCorrect ? 420 : 320;
            const life = Math.round(baseLife * (0.92 + comboBoost * 0.22));
            gameState.clickEffects.push({
                x: node.x,
                y: node.y,
                life,
                maxLife: life,
                ringRadius: node.radius * 0.6,
                ringGrow: (isCorrect ? 2.9 : 2.3) * (0.9 + comboBoost * 0.25),
                ringWidth: (isCorrect ? 3.2 : 2.6) * (0.88 + comboBoost * 0.15),
                color: baseColor,
                particles
            });
        }

        function createWordCompleteEffect(node) {
            if (!node) return;
            const burst = (scale, color) => {
                const particles = [];
                const count = Math.round(34 * scale);
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.35;
                    const speed = (3.4 + Math.random() * 3.1) * scale;
                    particles.push({
                        x: node.x,
                        y: node.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: (3 + Math.random() * 2.8) * scale,
                        alpha: 1,
                        drag: 0.968 + Math.random() * 0.012
                    });
                }
                const life = Math.round(520 * scale);
                gameState.clickEffects.push({
                    x: node.x,
                    y: node.y,
                    life,
                    maxLife: life,
                    ringRadius: node.radius * (0.7 + 0.4 * scale),
                    ringGrow: 4.2 * scale,
                    ringWidth: 4.2 * scale,
                    color,
                    particles
                });
            };

            burst(1.25, [125, 255, 170]);
            setTimeout(() => burst(1.0, [76, 235, 120]), 90);
            setTimeout(() => burst(0.85, [190, 255, 220]), 170);
        }

        function updateClickEffects(dt) {
            if (gameState.clickEffects.length === 0) return;
            const step = Math.max(0.6, Math.min(2.4, dt / 16.666));
            gameState.clickEffects.forEach(fx => {
                fx.life -= dt;
                fx.ringRadius += fx.ringGrow * step;
                fx.particles.forEach(p => {
                    p.x += p.vx * step;
                    p.y += p.vy * step;
                    p.vx *= p.drag;
                    p.vy *= p.drag;
                    p.alpha *= 0.92;
                });
                fx.particles = fx.particles.filter(p => p.alpha > 0.06);
            });
            gameState.clickEffects = gameState.clickEffects.filter(fx => fx.life > 0 && fx.particles.length > 0);
        }

        function drawClickEffects() {
            if (gameState.clickEffects.length === 0) return;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            gameState.clickEffects.forEach(fx => {
                const k = Math.max(0, fx.life / fx.maxLife);
                const c = fx.color;
                ctx.strokeStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${0.38 * k})`;
                ctx.lineWidth = fx.ringWidth * (0.7 + 0.6 * k);
                ctx.beginPath();
                ctx.arc(fx.x, fx.y, fx.ringRadius, 0, Math.PI * 2);
                ctx.stroke();

                fx.particles.forEach(p => {
                    ctx.fillStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${Math.min(1, p.alpha * k)})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
            ctx.restore();
        }

        // --- 5. åŒæ¨¡è¾“å…¥ä¸æ ¸å¿ƒæœºåˆ¶ ---
        function screenToWorld(screenX, screenY) {
            const centerX = width / 2;
            const centerY = height / 2;
            const z = gameState.cameraZoom || 1;
            return {
                x: ((screenX - centerX) / z) + centerX - gameState.cameraX,
                y: ((screenY - centerY) / z) + centerY - gameState.cameraY
            };
        }

        window.addEventListener('keydown', (e) => {
            // å¤„ç†å¿«é€Ÿè®°å¿†è¯¢é—®ç•Œé¢çš„é”®ç›˜äº‹ä»¶
            if (gameState.isPromptingMemo) {
                if (e.key.toUpperCase() === 'Y') {
                    showQuickMemo();
                } else if (e.key.toUpperCase() === 'N' || e.key === 'Escape') {
                    dismissQuickMemo();
                }
                return;
            }
            
            // å¤„ç†å¿«é€Ÿè®°å¿†å±•ç¤ºç•Œé¢çš„é”®ç›˜äº‹ä»¶
            if (gameState.isShowingMemo) {
                if (e.key === ' ' || e.key === 'Escape' || e.key === 'Enter') {
                    e.preventDefault();
                    dismissQuickMemo();
                }
                return;
            }
            
            if (gameState.isTransitioning || gameState.isSettling || gameState.isAutoDrawing) return;
            
            const pressedKey = e.key.toUpperCase();
            
            // å¤„ç†é€€æ ¼é”®ä¿®å‰ª
            if (e.key === 'Backspace') {
                e.preventDefault();
                pruneNode();
                return;
            }

            // ä»…å¤„ç†å­—æ¯é”®
            if (!/^[A-Z]$/.test(pressedKey)) return;

            handleInput(pressedKey);
        });

        canvas.addEventListener('pointerdown', (e) => {
            gameState.isDragging = true;
            gameState.dragStartY = e.clientY;
            gameState.dragStartCameraY = gameState.cameraY;
            gameState.dragMoved = false;
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!gameState.isDragging) return;
            const dy = e.clientY - gameState.dragStartY;
            if (Math.abs(dy) > 5) {
                gameState.dragMoved = true;
                gameState.cameraY = gameState.dragStartCameraY + dy;
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            if (gameState.isDragging && !gameState.dragMoved) {
                if (gameState.isBrowsing && gameState._backBtnRect) {
                    const rect2 = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect2.left;
                    const my = e.clientY - rect2.top;
                    const b = gameState._backBtnRect;
                    if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
                        const lastNode = gameState.nodes[gameState.nodes.length - 1];
                        if (lastNode) {
                            gameState.targetCameraY = height * 0.5 - lastNode.y;
                        }
                        gameState.isBrowsing = false;
                        gameState.isDragging = false;
                        gameState.dragMoved = false;
                        return;
                    }
                }
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPoint = screenToWorld(mouseX, mouseY);

                for (let i = gameState.labelHitAreas.length - 1; i >= 0; i--) {
                    const area = gameState.labelHitAreas[i];
                    if (worldPoint.x >= area.x && worldPoint.x <= area.x + area.w && worldPoint.y >= area.y && worldPoint.y <= area.y + area.h) {
                        speakWordPhrase(area.word);
                        gameState.isDragging = false;
                        gameState.dragMoved = false;
                        return;
                    }
                }

                if (!gameState.isTransitioning && !gameState.isAutoDrawing) {
                    const clickX = worldPoint.x;
                    const clickY = worldPoint.y;

                    for (let i = 0; i < gameState.activeOptions.length; i++) {
                        const option = gameState.activeOptions[i];
                        const dx = clickX - option.x;
                        const dy2 = clickY - option.y;
                        const distance = Math.sqrt(dx * dx + dy2 * dy2);
                        if (distance <= option.radius * 1.5) {
                            handleInput(option.letter);
                            break;
                        }
                    }
                }
            } else if (gameState.dragMoved) {
                gameState.isBrowsing = true;
            }
            gameState.isDragging = false;
            gameState.dragMoved = false;
        });

        canvas.addEventListener('pointerleave', () => {
            if (gameState.isDragging && gameState.dragMoved) {
                gameState.isBrowsing = true;
            }
            gameState.isDragging = false;
            gameState.dragMoved = false;
        });

        function handleInput(letter) {
            const nextIdx = gameState.currentStepIndex + 1;
            if (nextIdx >= gameState.parsedSteps.length) return;
            const nextStep = gameState.parsedSteps[nextIdx];
            if (nextStep.type !== 'input') return;
            const correctLetter = nextStep.char;

            const selectedOption = gameState.activeOptions.find(opt => opt.letter === letter);

            if (selectedOption) {
                if (gameState.isBrowsing) {
                    gameState.isBrowsing = false;
                    const currentNode = gameState.nodes[gameState.nodes.length - 1];
                    if (currentNode) {
                        gameState.targetCameraY = height * 0.5 - currentNode.y;
                        gameState.targetCameraX = width * 0.5 - currentNode.x;
                    }
                }
                if (selectedOption.isCorrect) {
                    advanceNode(selectedOption);
                } else {
                    handleMistake(selectedOption);
                }
            }
        }

        function advanceNode(selectedOption) {
            playCorrectNote();
            createClickEffect(selectedOption, true);
            const margin = 40;
            selectedOption.x = Math.max(margin, Math.min(width - margin, selectedOption.x));
            
            selectedOption.state = 'completed';
            selectedOption.scale = 1.2;
            setTimeout(() => selectedOption.targetScale = 1, 100);
            gameState.nodes.push(selectedOption);

            gameState.currentStepIndex++;
            gameState.score += 10 * gameState.combo;
            gameState.combo++;
            gameState.mistakeCount = 0;
            updateUI();

            gameState.targetCameraY = height * 0.5 - selectedOption.y;
            gameState.targetCameraX = width * 0.5 - selectedOption.x;

            advanceAfterStep(selectedOption);
        }

        function handleMistake(wrongOption) {
            playWrongNote();
            createClickEffect(wrongOption, false);
            const now = Date.now();
            
            // è®°å½•å•è¯é”™è¯¯æ¬¡æ•°
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            const wordKey = currentWordObj.word;
            gameState.wordMistakeMap[wordKey] = (gameState.wordMistakeMap[wordKey] || 0) + 1;
            
            dailyStats.mistakes++;
            saveDailyStats();
            
            // è®°å½•å†å²é”™è¯¯å­—æ¯
            if (!gameState.historicalMistakes[wordKey]) {
                gameState.historicalMistakes[wordKey] = [];
            }
            if (!gameState.historicalMistakes[wordKey].includes(wrongOption.letter)) {
                gameState.historicalMistakes[wordKey].push(wrongOption.letter);
            }
            
            // è§†è§‰åé¦ˆï¼šèŠ‚ç‚¹å˜çº¢å¹¶æ·¡å‡º
            wrongOption.state = 'wrong';
            wrongOption.targetScale = 0.8;
            
            // å°†é”™è¯¯èŠ‚ç‚¹ç§»å…¥ fadingNodes æ•°ç»„ï¼Œä»¥ä¾¿é‡æ–°ç”Ÿæˆé€‰é¡¹æ—¶å®ƒè¿˜èƒ½ç»§ç»­æ˜¾ç¤ºæ·¡å‡ºåŠ¨ç”»
            gameState.fadingNodes.push(wrongOption);
            setTimeout(() => wrongOption.state = 'fading', 300);

            // é€»è¾‘åé¦ˆï¼šé‡ç½® Combo
            gameState.combo = 1;
            updateUI();

            // å±å¹•éœ‡åŠ¨æ•ˆæœ (ç®€å•å®ç°ï¼šç»™ body åŠ ä¸ª class)
            document.body.style.transform = 'translate(5px, 5px)';
            setTimeout(() => document.body.style.transform = 'translate(-5px, -5px)', 50);
            setTimeout(() => document.body.style.transform = 'translate(5px, -5px)', 100);
            setTimeout(() => document.body.style.transform = 'translate(0, 0)', 150);
            
            // é”™è¯¯è®¡æ•°é€»è¾‘
            if (now - gameState.lastMistakeTime < 3000) {
                // 3ç§’å†…è¿ç»­é”™è¯¯
                gameState.mistakeCount++;
            } else {
                gameState.mistakeCount = 1;
            }
            gameState.lastMistakeTime = now;
            
            if (gameState.mistakeCount >= 3) {
                // è¿ç»­é”™è¯¯3æ¬¡ï¼Œè§¦å‘å¼ºåˆ¶è®°å¿†
                triggerMemorization();
            } else {
                // é‡æ–°ç”Ÿæˆé€‰é¡¹ï¼Œé˜²æ­¢çŒœæµ‹
                const parentNode = gameState.nodes[gameState.nodes.length - 1];
                generateOptions(parentNode);
            }
        }

        function triggerMemorization() {
            dailyStats.deaths++;
            saveDailyStats();
            
            gameState.isTransitioning = true;
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            
            const overlay = document.getElementById('memorizeOverlay');
            document.getElementById('memoWord').innerText = formatWord(currentWordObj.word);
            document.getElementById('memoMeaning').innerText = currentWordObj.meaning;
            const countdownEl = document.getElementById('memoCountdown');
            
            overlay.classList.remove('hidden');
            
            let timeLeft = 10;
            countdownEl.innerText = timeLeft;
            
            const timer = setInterval(() => {
                timeLeft--;
                countdownEl.innerText = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    overlay.classList.add('hidden');
                    
                    // æ‰æ ¹æŒ‘æˆ˜ï¼šå¦‚æœé”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œå¼ºåˆ¶å€’åºæ‹¼å†™
                    const wordKey = currentWordObj.word;
                    if (gameState.wordMistakeMap[wordKey] > 2) {
                        startGroundingMode();
                    } else {
                        // é‡ç½®å½“å‰å•è¯çš„è¿›åº¦
                        resetCurrentWord();
                    }
                }
            }, 1000);
        }

        function startGroundingMode() {
            // ç®€å•çš„æ‰æ ¹æŒ‘æˆ˜ï¼šé‡ç½®å•è¯ï¼Œä½†æç¤ºç”¨æˆ·éœ€è¦æ›´åŠ å°å¿ƒ
            // å¯ä»¥åœ¨è¿™é‡ŒåŠ å…¥æ›´å¤æ‚çš„é€»è¾‘ï¼Œæ¯”å¦‚å€’åºæ‹¼å†™ï¼Œè¿™é‡Œä¸ºäº†ä¿æŒä»£ç ç®€æ´ï¼Œæˆ‘ä»¬åªåšæç¤ºå¹¶é‡ç½®
            alert("æ‰æ ¹æŒ‘æˆ˜ï¼šè¯·ä»”ç»†æ‹¼å†™ï¼");
            resetCurrentWord();
        }

        function resetCurrentWord() {
            gameState.mistakeCount = 0;
            gameState.currentStepIndex = 0;
            
            gameState.nodes = gameState.nodes.slice(0, gameState.currentWordStartIndex + 1);
            
            const rootNode = gameState.nodes[gameState.nodes.length - 1];
            
            gameState.targetCameraY = height * 0.5 - rootNode.y;
            gameState.targetCameraX = width * 0.5 - rootNode.x;
            
            gameState.isTransitioning = false;
            updateUI();
            advanceAfterStep(rootNode);
        }

        function updateUI() {
            document.getElementById('scoreDisplay').innerText = gameState.score;
            document.getElementById('comboDisplay').innerText = `x${gameState.combo}`;
            document.getElementById('currentMeaningDisplay').innerText = currentDictionary[gameState.currentWordIndex].meaning;
            
            const totalWords = dictionaries[currentDictName] ? dictionaries[currentDictName].length : currentDictionary.length;
            const learnedWords = getLearnedCount(currentDictName);
            document.getElementById('progressDisplay').innerText = `${learnedWords}/${totalWords}`;
            
            const steps = gameState.parsedSteps;
            let html = '';
            let isFirstLetter = true;
            for (let i = 0; i < steps.length; i++) {
                const s = steps[i];
                let d = s.type === 'input' ? s.displayChar : s.display;
                if (s.type === 'input' && isFirstLetter) {
                    d = d.toUpperCase();
                    isFirstLetter = false;
                }
                if (s.type === 'auto' && s.subType === 'space') {
                    isFirstLetter = true;
                }
                const escaped = d.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                if (i <= gameState.currentStepIndex) {
                    html += `<span style="color:#4CAF50;">${escaped}</span>`;
                }
            }
            document.getElementById('selectedLettersDisplay').innerHTML = html;
        }

        // --- å¿«é€Ÿè®°å¿†ç³»ç»Ÿ ---
        function promptQuickMemo() {
            gameState.isPromptingMemo = true;
            document.getElementById('quickMemoPromptOverlay').classList.remove('hidden');
        }

        function showQuickMemo() {
            gameState.isPromptingMemo = false;
            gameState.isShowingMemo = true;
            document.getElementById('quickMemoPromptOverlay').classList.add('hidden');
            
            const listEl = document.getElementById('quickMemoList');
            listEl.innerHTML = '';
            
            // å¦‚æœæ˜¯æ¸¸æˆåˆšå¼€å§‹ï¼ˆnodesä¸ºç©ºï¼‰ï¼Œä»å½“å‰indexå¼€å§‹ï¼Œå¦åˆ™ä»ä¸‹ä¸€ä¸ªå•è¯å¼€å§‹
            const startIdx = gameState.nodes.length === 0 ? gameState.currentWordIndex : gameState.currentWordIndex + 1;
            const endIdx = Math.min(startIdx + gameState.clusterSize, currentDictionary.length);
            
            for (let i = startIdx; i < endIdx; i++) {
                const item = currentDictionary[i];
                const row = document.createElement('div');
                row.style.cssText = 'padding: 6px 0; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; gap: 12px; cursor: pointer;';
                row.innerHTML = `<span style="color: #4CAF50; font-weight: bold; letter-spacing: 1px; white-space: nowrap; flex-shrink: 0;">${formatWord(item.word)}</span><span style="color: #ccc; text-align: right;">${item.meaning}</span>`;
                row.addEventListener('click', () => {
                    speakWordPhrase(item.word);
                });
                listEl.appendChild(row);
            }
            
            document.getElementById('quickMemoDisplayOverlay').classList.remove('hidden');
        }

        function dismissQuickMemo() {
            gameState.isPromptingMemo = false;
            gameState.isShowingMemo = false;
            document.getElementById('quickMemoPromptOverlay').classList.add('hidden');
            document.getElementById('quickMemoDisplayOverlay').classList.add('hidden');
            
            if (gameState.nodes.length === 0) {
                startGameplay();
            } else {
                startNextWord();
            }
        }

        document.getElementById('btnQuickMemoYes').addEventListener('click', () => showQuickMemo());
        document.getElementById('btnQuickMemoNo').addEventListener('click', () => dismissQuickMemo());
        document.getElementById('btnQuickMemoDone').addEventListener('click', () => dismissQuickMemo());

        // --- 6. æ™ºèƒ½å¹²æ‰°é¡¹ä¸æ— ç¼è¡”æ¥ ---
        function generateOptions(parentNode) {
            const nextIdx = gameState.currentStepIndex + 1;
            if (nextIdx >= gameState.parsedSteps.length) return;
            const nextStep = gameState.parsedSteps[nextIdx];
            if (nextStep.type !== 'input') return;
            const correctLetter = nextStep.char;
            
            const distractors = getDistractors(correctLetter);
            
            const options = [correctLetter, ...distractors];
            options.sort(() => Math.random() - 0.5);

            gameState.activeOptions = [];
            
            // æ‰‡å½¢åˆ†å¸ƒå‚æ•°
            const numOptions = options.length;
            const spreadAngle = Math.PI / 3 + (numOptions - 3) * (Math.PI / 8);
            const startAngle = -Math.PI / 2 - spreadAngle / 2;
            const angleStep = numOptions > 1 ? spreadAngle / (numOptions - 1) : 0;
            const distance = numOptions > 3 ? 80 + (numOptions - 3) * 20 : 80;

            const margin = 40;
            const desiredGap = 52;
            const availableWidth = Math.max(60, width - margin * 2);
            const minGap = numOptions > 1
                ? Math.min(desiredGap, availableWidth / (numOptions - 1))
                : desiredGap;

            const positioned = options.map((letter, index) => {
                const angle = startAngle + index * angleStep;
                let x = parentNode.x + Math.cos(angle) * distance;
                x = Math.max(margin, Math.min(width - margin, x));
                const y = parentNode.y + Math.sin(angle) * distance;
                return { letter, x, y };
            });

            positioned.sort((a, b) => a.x - b.x);

            for (let i = 1; i < positioned.length; i++) {
                if (positioned[i].x - positioned[i - 1].x < minGap) {
                    positioned[i].x = positioned[i - 1].x + minGap;
                }
            }

            const rightOverflow = positioned.length > 0 ? positioned[positioned.length - 1].x - (width - margin) : 0;
            if (rightOverflow > 0) {
                positioned.forEach(p => p.x -= rightOverflow);
            }

            const leftOverflow = positioned.length > 0 ? margin - positioned[0].x : 0;
            if (leftOverflow > 0) {
                positioned.forEach(p => p.x += leftOverflow);
            }

            positioned.forEach(item => {
                item.x = Math.max(margin, Math.min(width - margin, item.x));
                const isCorrect = item.letter === correctLetter;
                const node = new Node(item.x, item.y, item.letter, isCorrect, parentNode);
                gameState.activeOptions.push(node);
            });
        }

        function getDistractors(correctLetter) {
            // ç®€å•çš„è¿‘éŸ³/è¿‘å½¢/ç›¸é‚»é”®ç®—æ³•
            const map = {
                'A': ['S', 'Q', 'Z'], 'B': ['V', 'N', 'P'], 'C': ['X', 'V', 'S'],
                'D': ['S', 'F', 'E'], 'E': ['W', 'R', 'D'], 'F': ['D', 'G', 'R'],
                'G': ['F', 'H', 'T'], 'H': ['G', 'J', 'Y'], 'I': ['U', 'O', 'K'],
                'J': ['H', 'K', 'U'], 'K': ['J', 'L', 'I'], 'L': ['K', 'O', 'P'],
                'M': ['N', 'J', 'K'], 'N': ['B', 'M', 'H'], 'O': ['I', 'P', 'L'],
                'P': ['O', 'Q', 'B'], 'Q': ['W', 'A', 'P'], 'R': ['E', 'T', 'F'],
                'S': ['A', 'D', 'W'], 'T': ['R', 'Y', 'G'], 'U': ['Y', 'I', 'J'],
                'V': ['C', 'B', 'F'], 'W': ['Q', 'E', 'S'], 'X': ['Z', 'C', 'S'],
                'Y': ['T', 'U', 'H'], 'Z': ['A', 'X', 'S']
            };
            
            let choices = map[correctLetter] || ['A', 'E', 'I', 'O', 'U'];

            let maxOptions = 3;
            if (gameState.combo >= 100) maxOptions = 6;
            else if (gameState.combo >= 50) maxOptions = 5;
            else if (gameState.combo >= 20) maxOptions = 4;
            const numDistractors = maxOptions - 1;

            choices.sort(() => Math.random() - 0.5);

            if (choices.length < numDistractors) {
                const allLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').filter(c => c !== correctLetter && !choices.includes(c));
                allLetters.sort(() => Math.random() - 0.5);
                choices = choices.concat(allLetters);
            }

            let distractors = choices.slice(0, numDistractors);
            
            // æ™ºèƒ½å›å£°ï¼šå¦‚æœå†å²ä¸Šæœ‰é”™è¯¯è®°å½•ï¼Œä¼˜å…ˆä½¿ç”¨å†å²é”™è¯¯å­—æ¯ä½œä¸ºå¹²æ‰°é¡¹
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            const wordKey = currentWordObj.word;
            if (gameState.historicalMistakes[wordKey] && gameState.historicalMistakes[wordKey].length > 0) {
                // éšæœºå–ä¸€ä¸ªå†å²é”™è¯¯å­—æ¯æ›¿æ¢æ‰ä¸€ä¸ªé»˜è®¤å¹²æ‰°é¡¹
                const histMistake = gameState.historicalMistakes[wordKey][Math.floor(Math.random() * gameState.historicalMistakes[wordKey].length)];
                if (histMistake !== correctLetter && !distractors.includes(histMistake)) {
                    distractors[0] = histMistake;
                }
            }
            
            return distractors;
        }

        function completeWord() {
            gameState.isTransitioning = true;
            gameState.activeOptions = []; // æ¸…ç©ºå½“å‰é€‰é¡¹

            // è®°å½•å†å²é”™è¯¯
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            speakWordPhrase(currentWordObj.word);
            const wordKey = currentWordObj.word;
            if (gameState.wordMistakeMap[wordKey] > 0) {
                // å¦‚æœè¿™ä¸ªå•è¯æœ‰é”™è¯¯ï¼Œè®°å½•ä¸‹æ¥
                if (!gameState.historicalMistakes[wordKey]) {
                    gameState.historicalMistakes[wordKey] = [];
                }
                // ç®€å•èµ·è§ï¼Œè¿™é‡Œåªè®°å½•æœ‰é”™è¯¯å‘ç”Ÿï¼Œå®é™…å¯ä»¥è®°å½•å…·ä½“æŒ‰é”™äº†å“ªä¸ªå­—æ¯
                // è¿™é‡Œæˆ‘ä»¬å‡è®¾åœ¨ handleMistake ä¸­è®°å½•äº†å…·ä½“å­—æ¯ï¼Œä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªè®°å½•å•è¯é”™è¯¯æ¬¡æ•°
            }

            // æ›´æ–°ç°‡è¿›åº¦
            gameState.wordsCompletedInCluster++;
            dailyStats.wordsCompleted++;
            saveDailyStats();
            updateProgressGauge();

            markWordLearned(currentDictName, currentWordObj.word);

            // åœ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—è®°å½•å•è¯æ ‡ç­¾
            const lastNode = gameState.nodes[gameState.nodes.length - 1];
            createWordCompleteEffect(lastNode);
            gameState.wordLabels.push({
                x: lastNode.x,
                y: lastNode.y,
                word: currentWordObj.word,
                meaning: currentWordObj.meaning
            });

            // æ˜¾ç¤ºå®Œæ•´å•è¯å’Œä¸­æ–‡é‡Šä¹‰
            const meaningDisplay = document.getElementById('meaningDisplay');
            meaningDisplay.innerHTML = `
                <div class="word">${formatWord(currentWordObj.word)}</div>
                <div class="meaning">${currentWordObj.meaning}</div>
            `;
            meaningDisplay.classList.add('show-meaning');

            // 1ç§’ååˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå•è¯æˆ–ç»“ç®—ç°‡
            setTimeout(() => {
                meaningDisplay.classList.remove('show-meaning');
                
                if (gameState.wordsCompletedInCluster >= gameState.clusterSize) {
                    settleCluster();
                } else if (gameState.currentWordIndex + 1 >= currentDictionary.length) {
                    // è¯åº“æ‰€æœ‰å•è¯å·²å®Œæˆ
                    settleCluster();
                } else {
                    startNextWord();
                }
            }, 1000);
        }

        function startNextWord() {
            gameState.currentWordIndex = (gameState.currentWordIndex + 1) % currentDictionary.length;
            
            const nextPhrase = currentDictionary[gameState.currentWordIndex].word;
            gameState.parsedSteps = parsePhrase(nextPhrase);
            gameState.currentStepIndex = 0;
            
            const lastNode = gameState.nodes[gameState.nodes.length - 1];
            const firstStep = gameState.parsedSteps[0];
            
            const newRootY = lastNode.y - 150;
            const newRootNode = new Node(width / 2, newRootY, firstStep.char, true);
            newRootNode.state = 'completed';
            newRootNode.scale = 0;
            newRootNode.targetScale = 1;
            
            newRootNode.isNewTreeRoot = true;
            gameState.nodes.push(newRootNode);
            
            gameState.currentWordStartIndex = gameState.nodes.length - 1;
            
            gameState.targetCameraY = height * 0.5 - newRootY;
            gameState.targetCameraX = 0;
            
            gameState.isTransitioning = false;
            updateUI();
            advanceAfterStep(newRootNode);
        }

        function settleCluster() {
            gameState.isSettling = true;
            
            // è§†è§’æ‹‰è¿œ
            gameState.targetCameraZoom = 0.5;
            // è‰²ç›¸åç§» (ä¾‹å¦‚æ¯æ¬¡åç§» 60 åº¦)
            gameState.targetBgHue = (gameState.bgHue + 60) % 360;
            
            // æ˜¾ç¤ºç»“ç®—å¡ç‰‡
            const card = document.getElementById('settlementCard');
            const title = document.getElementById('settlementTitle');
            const stats = document.getElementById('settlementStats');
            
            title.innerText = `Cluster Completed!`;
            stats.innerText = `Words: ${gameState.clusterSize} | Mistakes: ${Object.values(gameState.wordMistakeMap).reduce((a, b) => a + b, 0)}`;
            
            card.classList.remove('hidden');
            
            // 3ç§’åæ¢å¤å¹¶è¿›å…¥ä¸‹ä¸€ä¸ªç°‡
            setTimeout(() => {
                card.classList.add('hidden');
                
                // æ¢å¤è§†è§’
                gameState.targetCameraZoom = 1.0;
                
                // é‡ç½®ç°‡çŠ¶æ€
                gameState.wordsCompletedInCluster = 0;
                gameState.wordMistakeMap = {};
                updateProgressGauge();
                
                gameState.isSettling = false;
                
                // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€ä¸ªå•è¯
                if (gameState.currentWordIndex + 1 < currentDictionary.length) {
                    // å…ˆè¯¢é—®æ˜¯å¦éœ€è¦å¿«é€Ÿè®°å¿†
                    promptQuickMemo();
                } else {
                    // æ‰€æœ‰å•è¯å®Œæˆäº†ï¼Œå¯ä»¥å›åˆ°èœå•
                    alert('æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰å•è¯ï¼');
                    document.getElementById('menuLayer').classList.remove('hidden');
                    document.getElementById('uiLayer').classList.add('hidden');
                    showMenuMainView();
                }
            }, 3000);
        }

        function skipWord() {
            if (gameState.isTransitioning || gameState.isSettling || gameState.isAutoDrawing) return;
            
            const currentWordObj = currentDictionary[gameState.currentWordIndex];
            const wordKey = currentWordObj.word;
            gameState.wordMistakeMap[wordKey] = (gameState.wordMistakeMap[wordKey] || 0) + 5;
            
            let lastNode = gameState.nodes[gameState.nodes.length - 1];
            
            for (let i = gameState.currentStepIndex + 1; i < gameState.parsedSteps.length; i++) {
                const step = gameState.parsedSteps[i];
                const display = step.type === 'input' ? step.char : step.display;
                const newNode = new Node(lastNode.x, lastNode.y - 60, display, true, lastNode);
                newNode.state = 'completed';
                if (step.type === 'auto') newNode.nodeType = step.subType;
                gameState.nodes.push(newNode);
                lastNode = newNode;
            }
            
            gameState.currentStepIndex = gameState.parsedSteps.length - 1;
            completeWord();
        }

        function pruneNode() {
            if (gameState.isTransitioning || gameState.isSettling || gameState.isAutoDrawing) return;
            if (gameState.currentStepIndex <= 0) return;
            
            const minNodeCount = gameState.currentWordStartIndex + 1;
            if (gameState.nodes.length <= minNodeCount) return;
            
            let target = gameState.currentStepIndex - 1;
            while (target > 0 && gameState.parsedSteps[target].type === 'auto') {
                target--;
            }
            
            const nodesToRemove = gameState.currentStepIndex - target;
            for (let i = 0; i < nodesToRemove; i++) {
                if (gameState.nodes.length > minNodeCount) gameState.nodes.pop();
            }
            gameState.currentStepIndex = target;
            
            const parentNode = gameState.nodes[gameState.nodes.length - 1];
            gameState.targetCameraY = height * 0.5 - parentNode.y;
            gameState.targetCameraX = width * 0.5 - parentNode.x;
            
            advanceAfterStep(parentNode);
            updateUI();
        }

        // åˆå§‹åŒ–åŠ è½½è¯åº“
        loadDictionaries();
        loadDailyStats();
        loadGameSettings();
    </script>
</body>
</html>